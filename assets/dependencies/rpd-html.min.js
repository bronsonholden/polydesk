;(function(global) {
  "use strict";

var Kefir = global.Kefir;
if ((typeof Kefir === 'undefined') &&
    (typeof require !== 'undefined')) Kefir = require('kefir');
if (!Kefir) throw new Error('Kefir.js (https://github.com/rpominov/kefir) is required for Rpd to work');

var VERSION = 'v2.1.1';

var Rpd = (function() {

injectKefirEmitter();

// Rpd.NOTHING, Rpd.ID_LENGTH, ...

//var PATCH_PROPS = [ 'title', '*handle' ];
var nodetypes = {}; var NODE_PROPS = [ 'title', '*inlets', '*outlets', 'prepare', 'process', 'tune', '*handle' ];
var channeltypes = {}; var INLET_PROPS = [ 'label', 'default', 'hidden', 'cold', 'readonly', 'allow', 'accept', 'adapt', 'tune', 'show', '*handle' ];
                       var OUTLET_PROPS = [ 'label', 'tune', 'show', '*handle' ];
                       var CHANNEL_PROPS = INLET_PROPS;
var noderenderers = {}; var NODE_RENDERER_PROPS = [ 'prepare', 'size', 'first', 'always' ];
var channelrenderers = {}; var CHANNEL_RENDERER_PROPS = [ 'prepare', 'show', 'edit' ];
var nodedescriptions = {};
var styles = {};
var nodetypeicons = {};
var toolkiticons = {};

var renderer_registry = {};

var event_types = { 'network/add-patch': [ 'patch' ] };
var rpdEvent = create_event_map(event_types);
var rpdEvents = create_events_stream(event_types, rpdEvent, 'network', Rpd);

rpdEvent['network/add-patch'].onValue(function(patch) { rpdEvents.plug(patch.events); });

var rendering;

function ƒ(v) { return function() { return v; } }

function create_rendering_stream() {
    var rendering = Kefir.emitter();
    rendering.map(function(rule) {
        return {
            rule: rule,
            func: function(patch) {
                patch.render(rule.aliases, rule.targets, rule.config)
            }
        }
    }).scan(function(prev, curr) {
        if (prev) rpdEvent['network/add-patch'].offValue(prev.func);
        rpdEvent['network/add-patch'].onValue(curr.func);
        return curr;
    }, null).last().onValue(function(last) {
        rpdEvent['network/add-patch'].offValue(last.func);
    });
    return rendering;
}

function /*Rpd.*/renderNext(aliases, targets, conf) {
    if (!rendering) rendering = create_rendering_stream();
    rendering.emit({ aliases: aliases, targets: targets, config: conf });
}

function /*Rpd.*/stopRendering() {
    if (rendering) {
        rendering.end();
        rendering = null;
    }
}

function /*Rpd.*/addPatch(arg0, arg1, arg2) {
    return addClosedPatch(arg0, arg1).open(arg2);
}

function /*Rpd.*/addClosedPatch(arg0, arg1) {
    var name = !is_object(arg0) ? arg0 : undefined; var def = arg1 || arg0;
    var instance = new Patch(name, def);
    rpdEvent['network/add-patch'].emit(instance);
    return instance;
}

// =============================================================================
// ================================== Patch ====================================
// =============================================================================

function Patch(name, def) {
    this.id = short_uid();
    this.name = name;
    this.def = def || {};

    var patch = this;

    var event_types = {
        'patch/is-ready':      [ ],
        'patch/open':          [ 'parent' ],
        'patch/close':         [ ],
        'patch/move-canvas':   [ 'position' ],
        'patch/resize-canvas': [ 'size' ],
        'patch/set-inputs':    [ 'inputs' ],
        'patch/set-outputs':   [ 'outputs' ],
        'patch/project':       [ 'node', 'target' ],
        'patch/refer':         [ 'node', 'target' ],
        'patch/add-node':      [ 'node' ],
        'patch/remove-node':   [ 'node' ]
    };
    this.event = create_event_map(event_types);
    this.events = create_events_stream(event_types, this.event, 'patch', this);

    if (this.def.handle) subscribe(this.events, this.def.handle);

    // this stream controls the way patch events reach the assigned renderer
    this.renderQueue = Kefir.emitter();
    var renderStream = Kefir.combine([ this.events ],
                  [ this.renderQueue.scan(function(storage, rule) {
                        var alias = rule.alias, target = rule.target, configuration = rule.config;
                        var renderer = storage[alias];
                        if (!renderer) {
                            renderer = {};
                            renderer.produce = renderer_registry[alias](patch);
                            renderer.handlers = [];
                            storage[alias] = renderer;
                        }
                        if (renderer.produce) {
                            var handler = renderer.produce(target, configuration);
                            if (handler) {
                                renderer.handlers.push(
                                    (typeof handler === 'function') ? handler
                                                                    : function(event) {
                                                                          if (handler[event.type]) handler[event.type](event);
                                                                      } );
                            }
                        }
                        return storage;
                    }, {}) ]);
    // we need to wait for first renderer and then push there events happened before, then proceed
    renderStream = renderStream.bufferBy(this.renderQueue).take(1).flatten().concat(renderStream);
    renderStream.onValue(function(value) {
                    var event = value[0], renderers = value[1];
                    var aliases = Object.keys(renderers);
                    var renderer, handlers;
                    for (var i = 0, il = aliases.length; i < il; i++) {
                        renderer = renderers[aliases[i]]; handlers = renderer.handlers;
                        for (var j = 0, jl = handlers.length; j < jl; j++) {
                            handlers[j](inject_render(clone_obj(event), aliases[i]));
                        }
                    }
                });

    // projections are connections between different patches; patch inlets looking in the outer
    // world are called "inputs" here, and outlets looking in the outer world are, correspondingly,
    // called "outputs"
    this.projections = Kefir.emitter();
    Kefir.combine(
        [ this.projections ],
        [ this.event['patch/set-inputs'],
          this.event['patch/set-outputs'] ]
    ).onValue(function(value) {
        var node = value[0], inputs = value[1], outputs = value[2];
        var inlet, outlet, input, output;
        for (var i = 0; i < inputs.length; i++) {
            inlet = node.addInlet(inputs[i].type, inputs[i].alias, inputs[i].def, inputs[i].render);
            inlet.event['inlet/update'].onValue((function(input) {
                return function(value) { input.receive(value); };
            })(inputs[i]));
        } // use inlet.onUpdate?
        for (i = 0; i < outputs.length; i++) {
            outlet = node.addOutlet(outputs[i].type, outputs[i].alias, outputs[i].def, outputs[i].render);
            outputs[i].event['outlet/update'].onValue((function(outlet) {
                return function(value) { outlet.send(value); };
            })(outlet));
        } // use output.onUpdate?
        patch.event['patch/project'].emit({ node: node, target: node.patch });
        node.patch.event['patch/refer'].emit({ node: node, target: patch });
    });

    this.nodesToRemove = Kefir.emitter();

    this.event['patch/is-ready'].emit();
}
Patch.prototype.render = function(aliases, targets, config) {
    aliases = Array.isArray(aliases) ? aliases : [ aliases ];
    targets = Array.isArray(targets) ? targets : [ targets ];
    for (var i = 0, il = aliases.length, alias; i < il; i++) {
        for (var j = 0, jl = targets.length, target; j < jl; j++) {
            alias = aliases[i]; target = targets[j];
            if (!renderer_registry[alias]) report_system_error(this, 'patch', 'Renderer \'' + alias + '\' is not registered');
            this.renderQueue.emit({ alias: alias, target: target, config: config });
        }
    }
    return this;
}
Patch.prototype.addNode = function(type, arg1, arg2, arg3) {
    var patch = this;

    var def = arg2 ? arg2 : (is_object(arg1) ? (arg1 || {}) : {});
    var title = is_object(arg1) ? undefined : arg1;
    if (title) def.title = title;
    var render = (arg1 && is_object(arg1)) ? arg2 : arg3;

    var node = new Node(type, this, def, render, function(node) {
        patch.events.plug(node.events);
        patch.event['patch/add-node'].emit(node);

        node.turnOn();
    });

    return node;
}
Patch.prototype.removeNode = function(node) {
    node.turnOff();
    this.event['patch/remove-node'].emit(node);
    this.events.unplug(node.events);
    return this;
}
Patch.prototype.open = function(parent) {
    this.event['patch/open'].emit(parent);
    return this;
}
Patch.prototype.close = function() {
    this.event['patch/close'].emit();
    return this;
}
Patch.prototype.inputs = function(list) {
    this.event['patch/set-inputs'].emit(list);
    return this;
}
Patch.prototype.outputs = function(list) {
    this.event['patch/set-outputs'].emit(list);
    return this;
}
Patch.prototype.project = function(node) {
    this.projections.emit(node);
    return this;
}
Patch.prototype.moveCanvas = function(x, y) {
    this.event['patch/move-canvas'].emit([x, y]);
    return this;
}
Patch.prototype.resizeCanvas = function(width, height) {
    this.event['patch/resize-canvas'].emit([width, height]);
    return this;
}

// =============================================================================
// ================================= Node ======================================
// =============================================================================

function Node(type, patch, def, render, callback) {
    this.type = type || 'core/basic';
    this.toolkit = extract_toolkit(type);
    this.id = short_uid();
    this.patch = patch;

    var event_types = {
        'node/turn-on':       [ ],
        'node/is-ready':      [ ],
        'node/process':       [ 'inlets', 'outlets' ],
        'node/turn-off':      [ ],
        'node/add-inlet':     [ 'inlet' ],
        'node/remove-inlet':  [ 'inlet' ],
        'node/add-outlet':    [ 'outlet' ],
        'node/remove-outlet': [ 'outlet' ],
        'node/move':          [ 'position' ],
        'node/configure':    [ 'props' ]
    };
    this.event = create_event_map(event_types);
    this.events = create_events_stream(event_types, this.event, 'node', this);

    var type_def = adapt_to_obj(nodetypes[this.type], this);
    if (!type_def) report_system_error(this, 'node', 'Node type \'' + this.type + '\' is not registered!');
    this.def = join_definitions(NODE_PROPS, def, type_def);

    this.render = join_render_definitions(NODE_RENDERER_PROPS, render,
                      prepare_render_obj(noderenderers[this.type], this));

    if (callback) callback(this);

    var node = this;

    if (this.def.handle) subscribe(this.events, this.def.handle);

    if (this.def.process) {

        var process_f = this.def.process;

        var process = Kefir.combine([

            // when new inlet was added, start monitoring its updates
            // as an active stream
            this.event['node/add-inlet'].flatMap(function(inlet) {
                var updates = inlet.event['inlet/update'].map(function(value) {
                    return { inlet: inlet, value: value };
                });;
                if (node.def.tune) updates = node.def.tune.bind(node)(updates);
                return updates;
            })

        ],
        [
            // collect all the existing outlets aliases as a passive stream
            this.event['node/add-outlet'].scan(function(storage, outlet) {
                storage[outlet.alias] = outlet;
                return storage;
            }, {})

        ])

        // do not fire any event until node is ready, then immediately fire them one by one, if any occured;
        // later events are fired after node/is-ready, corresponding to their time of firing, as usual
        process = process.bufferBy(this.event['node/is-ready']).take(1).flatten().concat(process);

        process = process.scan(function(storage, update) {
            // update[0] is inlet value update, update[1] is a list of outlets
            var inlet = update[0].inlet;
            var alias = inlet.alias;
            storage.inlets.prev[alias] = storage.inlets.cur[alias];
            storage.inlets.cur[alias] = update[0].value;
            storage.outlets = update[1];
            storage.source = inlet;
            return storage;
        }, { inlets: { prev: {}, cur: {} }, outlets: {} }).changes();

        // filter cold inlets, so the update data will be stored, but process event won't fire
        process = process.filter(function(data) { return !data.source.def.cold; });

        process.onValue(function(data) {
            // call a node/process event using collected inlet values
            var outlets_vals = process_f.bind(node)(data.inlets.cur, data.inlets.prev);
            node.event['node/process'].emit({ inlets: data.inlets.cur, outlets: outlets_vals });
            // send the values provided from a `process` function to corresponding outlets
            var outlets = data.outlets;
            for (var outlet_name in outlets_vals) {
                if (outlets[outlet_name]) {
                    if (outlets_vals[outlet_name] instanceof Kefir.Stream) {
                        outlets[outlet_name].stream(outlets_vals[outlet_name]);
                    } else {
                        outlets[outlet_name].send(outlets_vals[outlet_name]);
                    }
                };
            }
        });

    }

    // only inlets / outlets described in type definition are stored inside
    // (since they are constructed once), it lets user easily connect to them

    if (this.def.inlets) {
        this.inlets = {};
        for (var alias in this.def.inlets) {
            var conf = this.def.inlets[alias];
            var inlet = this.addInlet(conf.type, alias, conf);
            this.inlets[alias] = inlet;
        }
    }

    if (this.def.outlets) {
        this.outlets = {};
        for (var alias in this.def.outlets) {
            var conf = this.def.outlets[alias];
            var outlet = this.addOutlet(conf.type, alias, conf);
            this.outlets[alias] = outlet;
        }
    }

    if (this.def.prepare) this.def.prepare.bind(this)(this.inlets, this.outlets);

    this.event['node/is-ready'].emit();
}
Node.prototype.turnOn = function() {
    this.event['node/turn-on'].emit();
    return this;
}
Node.prototype.turnOff = function() {
    this.event['node/turn-off'].emit();
    return this;
}
Node.prototype.addInlet = function(type, alias, arg2, arg3, arg4) {
    var def = arg3 ? arg3 : (is_object(arg2) ? (arg2 || {}) : {});
    var label = is_object(arg2) ? undefined : arg2;
    if (label) def.label = label;
    var render = (arg2 && is_object(arg2)) ? arg3 : arg4;

    var inlet = new Inlet(type, this, alias, def, render);
    this.events.plug(inlet.events);

    this.event['node/add-inlet'].emit(inlet);
    inlet.toDefault();
    return inlet;
}
Node.prototype.addOutlet = function(type, alias, arg2, arg3, arg4) {
    var def = arg3 ? arg3 : (is_object(arg2) ? (arg2 || {}) : {});
    var label = is_object(arg2) ? undefined : arg2;
    if (label) def.label = label;
    var render = (arg2 && is_object(arg2)) ? arg3 : arg4;

    var outlet = new Outlet(type, this, alias, def, render);
    this.events.plug(outlet.events);
    this.event['node/add-outlet'].emit(outlet);
    outlet.toDefault();
    return outlet;
}
Node.prototype.removeInlet = function(inlet) {
    this.event['node/remove-inlet'].emit(inlet);
    this.events.unplug(inlet.events);
    return this;
}
Node.prototype.removeOutlet = function(outlet) {
    this.event['node/remove-outlet'].emit(outlet);
    this.events.unplug(outlet.events);
    return this;
}
Node.prototype.move = function(x, y) {
    this.event['node/move'].emit([ x, y ]);
    return this;
}
Node.prototype.configure = function(props) {
    this.event['node/configure'].emit(props);
    return this;
}

// =============================================================================
// ================================== Inlet ====================================
// =============================================================================

function Inlet(type, node, alias, def, render) {
    this.type = type || 'core/any';
    this.toolkit = extract_toolkit(type);
    this.id = short_uid();
    this.alias = alias;
    this.node = node;

    var type_def = adapt_to_obj(channeltypes[this.type], this);
    if (!type_def) report_system_error(this, 'inlet', 'Channel type \'' + this.type + '\' is not registered!');
    this.def = join_definitions(INLET_PROPS, def, type_def);

    if (!this.alias) report_error(this, 'inlet', 'Inlet should have an alias');

    this.value = Kefir.pool();

    this.render = join_render_definitions(CHANNEL_RENDERER_PROPS, render,
                      prepare_render_obj(channelrenderers[this.type], this));

    var event_types = {
        'inlet/update': [ 'value' ]
    };
    this.event = create_event_map(event_types);
    var orig_updates = this.event['inlet/update'];
    var updates = orig_updates.merge(this.value);
    if (this.def.tune) updates = this.def.tune.bind(this)(updates);
    if (this.def.accept) updates = updates.flatten(function(v) {
        if (this.def.accept(v)) { return [v]; } else {
            orig_updates.error(make_silent_error(this, 'inlet')); return [];
        }
    }.bind(this));
    if (this.def.adapt) updates = updates.map(this.def.adapt);
    // rewrite with the modified stream
    this.event['inlet/update'] = updates.onValue(function(){});
    this.events = create_events_stream(event_types, this.event, 'inlet', this);

    if (this.def.handle) subscribe(this.events, this.def.handle);
}
Inlet.prototype.receive = function(value) {
    this.value.plug(Kefir.constant(value));
    return this;
}
Inlet.prototype.stream = function(stream) {
    this.value.plug(stream);
    return this;
}
Inlet.prototype.toDefault = function() {
    if (is_defined(this.def.default)) {
        if (this.def.default instanceof Kefir.Stream) {
            this.stream(this.def.default);
        } else this.receive(this.def.default);
    }
    return this;
}
Inlet.prototype.allows = function(outlet) {
    if (this.type === 'core/any') return true;
    if (outlet.type === this.type) return true;
    if (!this.def.allow && (outlet.type !== this.type)) return false;
    if (this.def.allow) {
        var matched = false;
        this.def.allow.forEach(function(allowedType) {
            if (outlet.type === allowedType) { matched = true; };
        });
        return matched;
    }
    return true;
}

// =============================================================================
// ================================= Outlet ====================================
// =============================================================================

function Outlet(type, node, alias, def, render) {
    this.type = type || 'core/any';
    this.toolkit = extract_toolkit(type);
    this.id = short_uid();
    this.alias = alias;
    this.node = node;

    var type_def = adapt_to_obj(channeltypes[this.type], this);
    if (!type_def) report_system_error(this, 'outlet', 'Channel type \'' + this.type + '\' is not registered!');
    this.def = join_definitions(OUTLET_PROPS, def, type_def);

    if (!this.alias) report_error(this, 'outlet', 'Outlet should have an alias');

    this.value = Kefir.pool();

    this.render = join_render_definitions(CHANNEL_RENDERER_PROPS, render,
                      prepare_render_obj(channelrenderers[this.type], this));

    // outlets values are not editable

    var event_types = {
        'outlet/update':     [ 'value' ],
        'outlet/connect':    [ 'link', 'inlet' ],
        'outlet/disconnect': [ 'link' ]
    };
    this.event = create_event_map(event_types);
    var orig_updates = this.event['outlet/update'];
    var updates = orig_updates.merge(this.value);
    // rewrite with the modified stream
    this.event['outlet/update'] = updates.onValue(function(v){});
    this.events = create_events_stream(event_types, this.event, 'outlet', this);

    if (this.def.handle) subscribe(this.events, this.def.handle);

    // re-send last value on connection
    var outlet = this;
    Kefir.combine([ this.event['outlet/connect'] ],
                  [ this.event['outlet/update'] ])
         .onValue(function(update) {
             outlet.value.plug(Kefir.constant(update[1]));
         });

}
Outlet.prototype.connect = function(inlet) {
    if (!inlet.allows(this)) {
        report_error(this, 'outlet', 'Outlet of type \'' + this.type + '\' is not allowed to connect to inlet of type \'' + inlet.type + '\'');
    }
    var link = new Link(this, inlet);
    this.events.plug(link.events);
    this.value.onValue(link.receiver);
    this.event['outlet/connect'].emit({ link: link, inlet: inlet });
    return link;
}
Outlet.prototype.disconnect = function(link) {
    this.event['outlet/disconnect'].emit(link);
    this.value.offValue(link.receiver);
    this.events.unplug(link.events);
    return this;
}
Outlet.prototype.send = function(value) {
    this.value.plug(Kefir.constant(value));
    return this;
}
Outlet.prototype.stream = function(stream) {
    this.value.plug(stream);
    return this;
}
Outlet.prototype.toDefault = function() {
    if (is_defined(this.def.default)) {
        if (this.def.default instanceof Kefir.Stream) {
            this.stream(this.def.default);
        } else this.send(this.def.default);
    }
    return this;
}

// =============================================================================
// ================================= Link ======================================
// =============================================================================

function Link(outlet, inlet, label) {
    this.id = short_uid();

    this.name = label || '';

    this.outlet = outlet;
    this.inlet = inlet;

    this.value = Kefir.emitter();

    var link = this;

    this.receiver = (outlet.node.id !== inlet.node.id)
        ? function(x) { link.pass(x); }
        : function(x) {
            // this avoids stack overflow on recursive connections
            setTimeout(function() { link.pass(x); }, 0);
        };

    var event_types = {
        'link/enable':  [ ],
        'link/disable': [ ],
        'link/pass':    [ 'value' ]
    };

    this.event = create_event_map(event_types);
    var orig_updates = this.event['link/pass'];
    var updates = orig_updates.merge(this.value);
    // rewrite with the modified stream
    this.event['link/pass'] = updates.onValue(function(v){});
    this.events = create_events_stream(event_types, this.event, 'link', this);

    this.enabled = Kefir.merge([ this.event['link/disable'].map(ƒ(false)),
                                 this.event['link/enable'].map(ƒ(true)) ]).toProperty(ƒ(true));

    this.event['link/pass'].filterBy(this.enabled).onValue(function(value) {
        inlet.receive(value);
    });

    // re-send last value on enable
    Kefir.combine([ this.event['link/enable'] ],
                  [ this.event['link/pass'] ])
         .onValue(function(event) {
              link.pass(event[1]);
          });
}
Link.prototype.pass = function(value) {
    this.value.emit(value);
    return this;
}
Link.prototype.enable = function() {
    this.event['link/enable'].emit();
    return this;
}
Link.prototype.disable = function() {
    this.event['link/disable'].emit();
    return this;
}
Link.prototype.disconnect = function() {
    this.outlet.disconnect(this);
    return this;
}

// =============================================================================
// ================================== utils ====================================
// =============================================================================

function injectKefirEmitter() {
    Kefir.emitter = function() {
        var e, stream = Kefir.stream(function(_e) {
            e = _e; return function() { e = undefined; }
        });
        stream.emit = function(x) { e && e.emit(x); return this; }
        stream.error = function(x) { e && e.error(x); return this; }
        stream.end = function() { e && e.end(); return this; }
        stream.emitEvent = function(x) { e && e.emitEvent(x); return this; }
        return stream.setName('emitter');
    }
}

function join_definitions(keys, src1, src2) {
    var trg = {}; src1 = src1 || {}; src2 = src2 || {};
    var key;
    for (var i = 0, il = keys.length; i < il; i++) {
        key = keys[i];
        if (key[0] !== '*') {
            if (!(key in src1) && !(key in src2)) continue;
            trg[key] = is_defined(src1[key]) ? src1[key] : src2[key];
        } else {
            key = key.slice(1);
            if (!(key in src1) && !(key in src2)) continue;
            trg[key] = {};
            var src2_keys = src2[key] ? Object.keys(src2[key]) : [];
            for (var j = 0, jl = src2_keys.length; j < jl; j++) {
                trg[key][src2_keys[j]] = src2[key][src2_keys[j]];
            }
            var src1_keys = src1[key] ? Object.keys(src1[key]) : [];
            for (var j = 0, jl = src1_keys.length; j < jl; j++) {
                trg[key][src1_keys[j]] = src1[key][src1_keys[j]];
            }
        }
    }
    return trg;
}

function clone_obj(src) {
    // this way is not a deep-copy and actually not cloning at all, but that's ok,
    // since we use it few times for events, which are simple objects and the objects they
    // pass, should be the same objects they got; just events by themselves should be different.
    var res = {}; var keys = Object.keys(src);
    for (var i = 0, il = keys.length; i < il; i++) {
        res[keys[i]] = src[keys[i]];
    }
    return res;
}

function is_object(val) {
    return (typeof val === 'object');
}

function is_defined(val) {
    return (typeof val !== 'undefined');
}

function adapt_to_obj(val, subj) {
    if (!val) return null;
    if (typeof val === 'function') return val(subj);
    return val;
}

function prepare_render_obj(template, subj) {
    if (!template) return {};
    var render_obj = {};
    for (var render_type in template) {
        render_obj[render_type] = adapt_to_obj(template[render_type], subj);
    }
    return render_obj;
}

function join_render_definitions(keys, user_render, type_render) {
    if (!user_render) return type_render;
    var result = {};
    for (var render_type in type_render) {
        result[render_type] = join_definitions(keys, user_render[render_type], type_render[render_type]);
    }
    for (var render_type in user_render) {
        if (!result[render_type] && !type_render[render_type]) result[render_type] = user_render[render_type];
    }
    return result;
}

function create_event_map(conf) {
    var map = {}; var types = Object.keys(conf);
    for (var i = 0, type; i < types.length; i++) {
        type = types[i];
        map[type] = Kefir.emitter();
    }
    return map;
}

function adapt_events(type, spec) {
    if (spec.length === 0) return function() { return { type: type } };
    if (spec.length === 1) return function(value) { var evt = {}; evt.type = type; evt[spec[0]] = value; return evt; };
    if (spec.length > 1)   return function(event) { event = clone_obj(event); event.type = type; return event; };
}
function create_events_stream(conf, event_map, subj_as, subj) {
    var stream = Kefir.pool(); var types = Object.keys(conf);
    for (var i = 0; i < types.length; i++) {
        stream.plug(event_map[types[i]]
                         .map(adapt_events(types[i], conf[types[i]]))
                         .map(function(evt) {
                             evt[subj_as] = subj;
                             return evt;
                         }));
    }
    return stream;
}

function subscribe(events, handlers) {
    events.filter(function(event) { return handlers[event.type]; })
          .onValue(function(event) {
              handlers[event.type](event);
          });
}

function make_silent_error(subject, subject_name) {
    return make_error(subject, subject_name, null, false, true);
}

function make_error(subject, subject_name, message, is_system, is_silent) {
    return { type: subject_name + '/error', system: is_system || false,
             subject: subject, message: message, silent: is_silent || false };
}

function report_error(subject, subject_name, message, is_system) {
    rpdEvents.plug(Kefir.constantError(make_error(subject, subject_name, message, is_system)));
}

function report_system_error(subject, subject_name, message) {
    report_error(subject, subject_name, message, true);
}

function short_uid() {
    return ("0000" + (Math.random() * Math.pow(36,4) << 0).toString(36)).slice(-4);
}

function inject_render(update, alias) {
    var type = update.type;
    if ((type === 'patch/add-node') || (type === 'node/process')) {
        update.render = update.node.render[alias] || {};
    } else if ((type === 'node/add-inlet')  || (type === 'inlet/update')) {
        update.render = update.inlet.render[alias] || {};
    } else if ((type === 'node/add-outlet')  || (type === 'outlet/update')) {
        update.render = update.outlet.render[alias] || {};
    }
    return update;
}

function get_style(name, renderer) {
    if (!name) report_system_error(null, 'network', 'Unknown style requested: \'' + name + '\'');
    if (!styles[name]) report_system_error(null, 'network', 'Style \'' + name + '\' is not registered');
    var style = styles[name][renderer];
    if (!style) report_system_error(null, 'network', 'Style \'' + name + '\' has no definition for \'' + renderer + '\' renderer');
    return style;
}

function extract_toolkit(type) {
    var slashPos = type.indexOf('/');
    return (slashPos >= 0) ? type.substring(0, slashPos) : '';
}

// =============================================================================
// =========================== registration ====================================
// =============================================================================

function nodetype(type, def) {
    nodetypes[type] = def || {};
}

function channeltype(type, def) {
    channeltypes[type] = def || {};
}

function renderer(alias, f) {
    renderer_registry[alias] = f;
}

function noderenderer(type, alias, data) {
    if (!nodetypes[type]) report_system_error(null, 'network', 'Node type \'' + type + '\' is not registered');
    if (!noderenderers[type]) noderenderers[type] = {};
    noderenderers[type][alias] = data;
}

function channelrenderer(type, alias, data) {
    if (!channeltypes[type]) report_system_error(null, 'network', 'Channel type \'' + type + '\' is not registered');
    if (!channelrenderers[type]) channelrenderers[type] = {};
    channelrenderers[type][alias] = data;
}

function nodedescription(type, description) {
    nodedescriptions[type] = description;
}

function style(name, renderer, func) {
    if (!styles[name]) styles[name] = {};
    styles[name][renderer] = func;
}

function toolkiticon(toolkit, icon) {
    toolkiticons[toolkit] = icon;
}

function nodetypeicon(type, icon) {
    nodetypeicons[type] = icon;
}

nodetype('core/basic', {});
nodetype('core/reference', {});
channeltype('core/any', {});

// =============================================================================
// ========================== stringification ==================================
// =============================================================================

var stringify = {};
stringify.patch = function(patch) {
    return '[ Patch' + (patch.name ? (' \'' + patch.name + '\'') : ' <Unnamed>') + ' ]';
};
stringify.node = function(node) {
    return '[ Node (' + node.type + ')' +
              (node.def ? (node.def.title ? (' \'' + node.def.title + '\'') : ' <Untitled>') : ' <Unprepared>') +
              ' #' + node.id +
              ' ]';
};
stringify.outlet = function(outlet) {
    return '[ Outlet (' + outlet.type + ')' +
              (outlet.alias ? (' \'' + outlet.alias + '\'') : ' <Unaliased>') +
              (outlet.def ? (outlet.def.label ? (' \'' + outlet.def.label + '\'') : ' <Unlabeled>') : ' <Unprepared>') +
              ' #' + outlet.id +
              ' ]';
};
stringify.inlet = function(inlet) {
    return '[ Inlet (' + inlet.type + ')' +
              (inlet.alias ? (' \'' + inlet.alias + '\'') : ' <Unaliased>') +
              (inlet.def ? (inlet.def.label ? (' \'' + inlet.def.label + '\'') : ' <Unlabeled>') : ' <Unprepared>') +
              ' #' + inlet.id +
              (inlet.def.hidden ? ' (hidden)' : '') +
              (inlet.def.cold ? ' (cold)' : '') +
              ' ]';
};
stringify.link = function(link) {
    return '[ Link (' + link.type + ')' +
              ' \'' + link.name + '\'' +
              ' #' + link.id +
              ' ' + stringify.outlet(link.outlet) + ' ->' +
              ' ' + stringify.inlet(link.inlet) +
              ' ]';
};

function autoStringify(value) {
    if (value instanceof Patch)  { return stringify.patch(value); }
    if (value instanceof Node)   { return stringify.node(value); }
    if (value instanceof Inlet)  { return stringify.inlet(value); }
    if (value instanceof Outlet) { return stringify.outlet(value); }
    if (value instanceof Link)   { return stringify.link(value); }
    return '<?> ' + value;
}

// =============================================================================
// =============================== export ======================================
// =============================================================================

return {

    'VERSION': VERSION,

    '_': { 'Patch': Patch, 'Node': Node, 'Inlet': Inlet, 'Outlet': Outlet, 'Link': Link },

    'unit': ƒ,
    'not': function(value) { return !value; },

    'event': rpdEvent,
    'events': rpdEvents,

    'addPatch': addPatch,
    'addClosedPatch': addClosedPatch,
    'renderNext': renderNext,
    'stopRendering': stopRendering,

    'nodetype': nodetype,
    'channeltype': channeltype,
    'nodedescription': nodedescription,

    'renderer': renderer, 'styles': styles, 'style': style,
    'noderenderer': noderenderer,
    'channelrenderer': channelrenderer,

    'toolkiticon': toolkiticon,
    'nodetypeicon': nodetypeicon,

    'import': {}, 'export': {},

    'allNodeTypes': nodetypes,
    'allChannelTypes': channeltypes,
    'allNodeRenderers': noderenderers,
    'allChannelRenderers': channelrenderers,
    'allNodeDescriptions': nodedescriptions,
    'allNodeTypeIcons': nodetypeicons,
    'allToolkitIcons': toolkiticons,

    'getStyle': get_style,
    'reportError': report_error,
    'reportSystemError': report_system_error,

    'short_uid': short_uid,

    'stringify': stringify,
    'autoStringify': autoStringify
}

})();

if (typeof define === 'function' && define.amd) {
    define([], function() { return Rpd; });
    global.Rpd = Rpd;
} else if (typeof module === "object" && typeof exports === "object") {
    module.exports = Rpd;
    Rpd.Rpd = Rpd;
} else {
    global.Rpd = Rpd;
}

}(this));

// source: https://gist.github.com/shamansir/a4459a588a12d4178197

var d3_tiny = (function() {

function modify(s, v, each) {
    var f = (typeof v === 'function') ? v : function() { return v; };
    var sel = s.selection;
    for (var i = 0, il = sel.length; i < il; i++) {
        each(sel[i], f.bind(sel[i])(i));
    };
    return s;
};

function Selection(v, root, all) {
    root = root || document;
    if (typeof v === 'string') selection = (all ? Array.prototype.slice.call(root.querySelectorAll(v), 0)
                                                : [ root.querySelector(v) ]);
    else if (v instanceof Node) selection = [ v ];
    else if (Array.isArray(v)) selection = v;
    else selection = [ v ];
    this.namespace = ((selection.length === 1) && selection[0]) ? selection[0].namespaceURI : null;
    this.selection = selection;
};

Selection.prototype.empty = function() {
    return (((this.selection.length === 1) && !this.selection[0]) || !this.selection.length) ? true : false;
};

Selection.prototype.attr = function(attr, val) {
    if ((typeof val === 'undefined') && (this.selection.length === 1)) return this.selection[0].getAttribute(attr);
    return modify(this, val, function(subj, s_val) { subj.setAttributeNS(null, attr, s_val); });
};

Selection.prototype.property = function(prop, val) {
    if ((typeof val === 'undefined') && (this.selection.length === 1)) return this.selection[0][prop];
    return modify(this, val, function(subj, s_val) { subj[prop] = s_val; });
};

Selection.prototype.style = function(prop, val) {
    if (prop[0] === '-') prop = prop.slice(1);
    prop = prop.replace(/-([a-z])/g, function(g) { return g[1].toUpperCase(); });
    return modify(this, val, function(subj, style) { subj.style[prop] = style; });
};

Selection.prototype.text = function(val) {
    if ((typeof val === 'undefined') && (this.selection.length === 1)) {
        return this.selection[0].textContent || this.selection[0].innerText;
    }
    return modify(this, val, function(subj, text) { subj.innerText = subj.textContent = text; });
}

Selection.prototype.classed = function(name, val) {
    if (typeof name === 'object') {
        var spec = name;
        return modify(this, Object.keys(spec), function(subj, list) {
            for (var i = 0, il = list.length; i < il; i++) { subj.classList.toggle(list[i], spec[list[i]]); }
        });
    } else {
        return modify(this, val, function(subj, flag) { subj.classList.toggle(name, flag); });
    }
}

Selection.prototype.select = function(v) { return new Selection(v, this.selection[0]); };

Selection.prototype.selectAll = function(v) { return new Selection(v, this.selection[0], true); };

Selection.prototype.append = function(name) {
    var selection = [];
    modify(this, (typeof name === 'string') ? document.createElementNS(this.namespace, name) : name,
                 function(subj, elm) { subj.appendChild(elm); selection.push(elm); });
    return new Selection(selection);
};

Selection.prototype.remove = function() {
    return modify(this, function() { return null; }, function(subj) {
        subj.parentElement.removeChild(subj);
    });
};

Selection.prototype.node = function(i) { return this.selection[i || 0]; }

Selection.prototype.parent = function() { return new Selection(this.selection.length ? this.selection[0].parentNode : []); }

Selection.prototype.on = function(event, handler) {
    return modify(this, function() { return handler; },
                  function(subj, handler) { subj.addEventListener(event, handler) });
};

Selection.prototype.data = function(val) {
    if (!val) return this.node().__data__;
    return modify(this, val, function(subj, data) { subj.__data__ = data; });
}

Selection.prototype.call = function(fn) { fn(this); return this; }

return { 'ns': { 'prefix': { 'svg': 'http://www.w3.org/2000/svg', 'html': 'http://www.w3.org/1999/xhtml' } },
         'select': function(v, root) { return new Selection(v, root); },
         'selectAll': function(v, root) { return new Selection(v, root, true); } };

})();

;(function(global) {
  "use strict";

var Rpd = global.Rpd;
if (typeof Rpd === "undefined" && typeof require !== "undefined") {
    Rpd = require('rpd');
}

Rpd.Render = (function() {

var ƒ = Rpd.unit;

var d3 = d3_tiny || d3;

// =============================================================================
// ============================= Placing =======================================
// =============================================================================

function GridPlacing(style) {
    this.nodeRects = [];
    this.edgePadding = style.edgePadding || { horizontal: 30, vertical: 20 };
    this.boxPadding  = style.boxPadding  || { horizontal: 20, vertical: 30 };
}
GridPlacing.DEFAULT_LIMITS = [ 1000, 1000 ]; // in pixels
GridPlacing.prototype.nextPosition = function(node, size, limits) {
    limits = limits || GridPlacing.DEFAULT_LIMITS;
    var nodeRects = this.nodeRects,
        boxPadding = this.boxPadding, edgePadding = this.edgePadding;
    var width =  size.width, height = size.height;
    var lastRect = (nodeRects.length ? nodeRects[nodeRects.length-1] : null);
    var newRect = { x: lastRect ? lastRect.x : edgePadding.horizontal,
                    y: lastRect ? (lastRect.y + lastRect.height + boxPadding.vertical)
                                : edgePadding.vertical,
                    width: width, height: height };
    if ((newRect.y + height + edgePadding.vertical) > limits.height) {
        newRect.x = newRect.x + width + boxPadding.horizontal;
        newRect.y = edgePadding.vertical;
    }
    nodeRects.push(newRect);
    return { x: newRect.x, y: newRect.y };
}

// =============================================================================
// ============================= DragAndDrop ===================================
// =============================================================================

function DragAndDrop(canvas, style) {
    this.canvas = canvas;
    this.style = style;
}

DragAndDrop.prototype.add = function(handle, spec) {
    var canvas = this.canvas; var style = this.style;
    var start = spec.start, end = spec.end, drag = spec.drag;
    Kefir.fromEvents(handle.node(), 'mousedown').map(extractPos)
                                                .map(style.getLocalPos)
                                                .flatMap(function(pos) {
        var initPos = start(),
            diffPos = { x: pos.x - initPos.x,
                        y: pos.y - initPos.y };
        var moveStream = Kefir.fromEvents(canvas.node(), 'mousemove')
                              .map(stopPropagation)
                              .takeUntilBy(Kefir.merge([
                                  Kefir.fromEvents(canvas.node(), 'mouseup'),
                                  Kefir.fromEvents(handle.node(), 'mouseup')
                              ]))
                              .map(extractPos)
                              .map(style.getLocalPos)
                              .map(function(absPos) {
                                  return { x: absPos.x - diffPos.x,
                                           y: absPos.y - diffPos.y };
                              }).toProperty(function() { return initPos; });
        moveStream.last().onValue(end);
        return moveStream;
    }).onValue(drag);
}

// =============================================================================
// ================================ Links ======================================
// =============================================================================

function VLink(link, style) { // visual representation of the link
    this.link = link; // may be null, if it's a ghost
    this.style = style;
    this.styledLink = null;
    this.element = null;
}
VLink.prototype.construct = function(width) {
    if (this.styledLink) throw new Error('VLink is already constructed');
    var styledLink = this.style.createLink(this.link);
    this.styledLink = styledLink;
    this.element = d3.select(styledLink.element);
    // html: this.element.style('z-index', LINK_LAYER);
    return this;
}
VLink.prototype.rotate = function(x0, y0, x1, y1) {
    var style = this.style;
    var sourcePos = style.getLocalPos({ x: x0, y: y0 });
    var targetPos = style.getLocalPos({ x: x1, y: y1 });
    this.styledLink.rotate(sourcePos.x, sourcePos.y,
                           targetPos.x, targetPos.y);
    return this;
}
VLink.prototype.rotateI = function(x0, y0, inlet) {
    var style = this.style;
    var inletPos  = style.getInletPos(inlet);
    return this.rotate(x0, y0, inletPos.x, inlet.y);
}
VLink.prototype.rotateO = function(outlet, x1, y1) {
    var style = this.style;
    var outletPos = style.getOutletPos(outlet);
    return this.rotate(outletPos.x, outletPos.y, x1, y1);
}
VLink.prototype.rotateOI = function(outlet, inlet) {
    var style = this.style;
    var outletPos = style.getOutletPos(outlet),
        inletPos  = style.getInletPos(inlet);
    return this.rotate(outletPos.x, outletPos.y, inletPos.x, inletPos.y);
}
VLink.prototype.update = function() {
    if (!this.link) return;
    var link = this.link;
    this.rotateOI(link.outlet, link.inlet);
    return this;
}
VLink.prototype.appendTo = function(target) {
    target.append(this.element.node());
    return this;
}
VLink.prototype.removeFrom = function(target) {
    this.element.remove();
    return this;
}
VLink.prototype.noPointerEvents = function() {
    if (this.styledLink.noPointerEvents) {
        this.styledLink.noPointerEvents();
    }
    return this;
}
VLink.prototype.listenForClicks = function() {
    var link = this.link;
    addClickSwitch(this.element.node(),
                   function() { link.enable(); },
                   function() { link.disable(); });
    return this;
}
VLink.prototype.enable = function() {
    this.element.classed('rpd-disabled', false);
}
VLink.prototype.disable = function() {
    this.element.classed('rpd-disabled', true);
}
VLink.prototype.get = function() {
    return this.link;
}
VLink.prototype.getElement = function() {
    return this.element.node();
}

function VLinks() {
    this.vlinks = [];
}
VLinks.prototype.clear = function() { this.vlinks = []; }
VLinks.prototype.add = function(vlink) {
    this.vlinks.push(vlink);
    return vlink;
}
VLinks.prototype.remove = function(vlink) {
    this.vlinks = this.vlinks.filter(function(my_vlink) {
        return my_vlink !== vlink;
    });
}
VLinks.prototype.forEach = function(f) {
    this.vlinks.forEach(f);
}
VLinks.prototype.updateAll = function() {
    this.forEach(function(vlink) { vlink.update(); });
}
VLinks.prototype.count = function() {
    return this.vlinks.length;
}
VLinks.prototype.getLast = function() {
    return this.count() ? this.vlinks[this.vlinks.length - 1] : null;
}

// =============================================================================
// =============================== helpers =====================================
// =============================================================================

function mergeConfig(user_conf, defaults) {
    if (user_conf) {
        var merged = {};
        Object.keys(defaults).forEach(function(prop) { merged[prop] = defaults[prop]; });
        Object.keys(user_conf).forEach(function(prop) { merged[prop] = user_conf[prop]; });
        return merged;
    } else return defaults;
}

function preventDefault(evt) { evt.preventDefault(); return evt; };
function stopPropagation(evt) { evt.stopPropagation(); return evt; };
function extractPos(evt) { return { x: evt.clientX,
                                    y: evt.clientY }; };
function addTarget(target) {
    return function(pos) {
        return { pos: pos, target: target };
    }
};
function addClickSwitch(elm, on_true, on_false, initial) {
    Kefir.fromEvents(elm, 'click')
         .map(stopPropagation)
         .map(ƒ(initial || false))
         .scan(Rpd.not)  // will toggle between `true` and `false`
         .onValue(function(val) {
             if (val) { on_true(); }
             else { on_false(); }
         })
}

var addValueErrorEffect = (function() {
    var errorEffects = {};
    return function(key, target, duration) {
        target.classed('rpd-error', true);
        if (errorEffects[key]) clearTimeout(errorEffects[key]);
        errorEffects[key] = setTimeout(function() {
            target.classed('rpd-error', false);
            errorEffects[key] = null;
        }, duration || 1);
    }
})();

var addValueUpdateEffect = (function() {
    var updateEffects = {};
    return function(key, target, duration) {
        target.classed('rpd-stale', false);
        target.classed('rpd-fresh', true);
        if (updateEffects[key]) clearTimeout(updateEffects[key]);
        updateEffects[key] = setTimeout(function() {
            target.classed('rpd-fresh', false);
            target.classed('rpd-stale', true);
            updateEffects[key] = null;
        }, duration || 1);
    }
})();

function subscribeUpdates(node, subscriptions) {
    if (!subscriptions) return;
    Object.keys(subscriptions).forEach(function(alias) {
        (function(subscription, alias) {
            node.event['node/add-inlet']
                .filter(function(inlet) { return inlet.alias === alias; })
                .onValue(function(inlet) {
                    node.event['node/is-ready'].onValue(function() {
                        if (subscription.default) {
                            inlet.receive(
                                (typeof subscription.default === 'function')
                                ? subscription.default() : subscription.default
                            );
                        }
                        if (subscription.valueOut) {
                            subscription.valueOut.onValue(function(value) {
                                inlet.receive(value);
                            });
                        }
                    });
                });
        })(subscriptions[alias], alias);
    });
}

// Should be called once when renderer registered and Rpd.events is ready
function reportErrorsToConsole(config) {
    Rpd.events.onError(function(error) {
        if (!config.logErrors) return;
        if (error.silent) return;
        var subjectStringified;
        try {
            subjectStringified = Rpd.autoStringify(error.subject);
        } catch (e) {
            subjectStringified = '<Unable-to-Stringify>';
        }
        if (error.system) {
            console.error(new Error(error.type + ' — ' + error.message + '. ' +
                          'Subject: ' + subjectStringified));
        } else {
            console.log('Error:', error.type, '—', error.message + '. ',
                        'Subject: ' + subjectStringified, error.subject);
        }
    });
}

return {
    Placing: GridPlacing,
    DragAndDrop: DragAndDrop,
    //Connectivity: Connectivity,

    VLink: VLink,
    VLinks: VLinks,

    mergeConfig: mergeConfig,

    preventDefault: preventDefault,
    stopPropagation: stopPropagation,

    extractPos: extractPos,

    addTarget: addTarget,
    addClickSwitch: addClickSwitch,

    addValueErrorEffect: addValueErrorEffect,
    addValueUpdateEffect: addValueUpdateEffect,

    subscribeUpdates: subscribeUpdates,

    reportErrorsToConsole: reportErrorsToConsole
};

})();

})(this);

;(function(global) {
  "use strict";

var Rpd = global.Rpd;
if (typeof Rpd === "undefined" && typeof require !== "undefined") {
    Rpd = require('rpd');
}

Rpd.style('blender', 'svg', function(config) {

var d3 = d3 || d3_tiny;

function _createSvgElement(name) {
    return document.createElementNS(d3.ns.prefix.svg, name);
}

var lastCanvas = null;

var socketPadding = 25, // distance between inlets/outlets in SVG units
    socketsMargin = 15; // distance between first/last inlet/outlet and body edge
var bodySizePadding = 30;
var headerHeight = 20; // height of a node header in SVG units

var letterWidth = 8;

var listeners = {};
var inletToConnector = {},
    outletToConnector = {};

var defs = d3.select(_createSvgElement('defs'));
// background blueprint pattern
defs.append('pattern').attr('id', 'blueprint-sub').attr('patternUnits', 'userSpaceOnUse')
                      .attr('width', 20).attr('height', 20)
                      .append('rect').attr('fill', 'transparent')
                                     .attr('stroke', '#2c2c2c').attr('stroke-width', 1)
                                     .attr('width', 20).attr('height', 20);
defs.append('pattern').attr('id', 'blueprint').attr('patternUnits', 'userSpaceOnUse')
                      .attr('width', 100).attr('height', 100)
                      .call(function(pattern) {
                          pattern.append('rect').attr('fill', '#323232')
                                                .attr('width', 100).attr('height', 100);
                          pattern.append('rect').attr('fill', 'url(#blueprint-sub)')
                                                .attr('width', 100).attr('height', 100);
                          pattern.append('rect').attr('fill', 'transparent')
                                                .attr('stroke', '#2c2c2c').attr('stroke-width', 2)
                                                .attr('width', 100).attr('height', 100);
                      });
// cyan header gradient
defs.append('linearGradient').attr('id', 'cyan-gradient')//.attr('gradientUnits', 'userSpaceOnUse')
                             .attr('x1', '50%').attr('y1', '100%').attr('x2', '50%').attr('y2', '0%')
                             .call(function(linearGradient) {
                                 linearGradient.append('stop').attr('offset', '0%')
                                                              .attr('style', 'stop-color:rgb(59,195,189);stop-opacity:0.5');
                                 linearGradient.append('stop').attr('offset', '90%')
                                                              .attr('style', 'stop-color:rgb(83,186,176);stop-opacity:0.55');
                                 linearGradient.append('stop').attr('offset', '100%')
                                                              .attr('style', 'stop-color:rgb(83,219,213);stop-opacity:0.6');
                             });
// gray header gradient
defs.append('linearGradient').attr('id', 'gray-gradient')//.attr('gradientUnits', 'userSpaceOnUse')
                             .attr('x1', '50%').attr('y1', '100%').attr('x2', '50%').attr('y2', '0%')
                             .call(function(linearGradient) {
                                 linearGradient.append('stop').attr('offset', '0%')
                                                              .attr('style', 'stop-color:rgb(110,110,110);stop-opacity:0.5');
                                 linearGradient.append('stop').attr('offset', '90%')
                                                              .attr('style', 'stop-color:rgb(115,115,115);stop-opacity:0.6');
                                 linearGradient.append('stop').attr('offset', '100%')
                                                              .attr('style', 'stop-color:rgb(135,135,135);stop-opacity:0.5');
                             });

// selection gradient
defs.append('linearGradient').attr('id', 'select-gradient')//.attr('gradientUnits', 'userSpaceOnUse')
                             .attr('x1', '50%').attr('y1', '100%').attr('x2', '50%').attr('y2', '0%')
                             .call(function(linearGradient) {
                                 linearGradient.append('stop').attr('offset', '0%')
                                                              .attr('style', 'stop-color:rgb(85,146,185);stop-opacity:1');
                                 linearGradient.append('stop').attr('offset', '71%')
                                                              .attr('style', 'stop-color:rgb(59,129,204);stop-opacity:1');
                                 linearGradient.append('stop').attr('offset', '100%')
                                                              .attr('style', 'stop-color:rgb(45,112,179);stop-opacity:1');
                             });

// deselection gradient
defs.append('linearGradient').attr('id', 'deselect-gradient')//.attr('gradientUnits', 'userSpaceOnUse')
                             .attr('x1', '50%').attr('y1', '100%').attr('x2', '50%').attr('y2', '0%')
                             .call(function(linearGradient) {
                                  linearGradient.append('stop').attr('offset', '0%')
                                                               .attr('style', 'stop-color:rgb(54,54,54);stop-opacity:1');
                                  linearGradient.append('stop').attr('offset', '70%')
                                                               .attr('style', 'stop-color:rgb(72,72,72);stop-opacity:1');
                                  linearGradient.append('stop').attr('offset', '100%')
                                                               .attr('style', 'stop-color:rgb(83,83,83);stop-opacity:1');
                             });

// link gradient
defs.append('radialGradient').attr('id', 'link-gradient')//.attr('gradientUnits', 'userSpaceOnUse')
                             .attr('cx', '50%').attr('cy', '50%').attr('r', '75%')
                             .call(function(radialGradient) {
                                 radialGradient.append('stop').attr('offset', '45%')
                                                              .attr('style', 'stop-color:rgb(255,255,255);stop-opacity:1');
                                 radialGradient.append('stop').attr('offset', '100%')
                                                              .attr('style', 'stop-color:rgb(150,150,150);stop-opacity:1');
                             });
// disabled link gradient
defs.append('radialGradient').attr('id', 'disabled-link-gradient')//.attr('gradientUnits', 'userSpaceOnUse')
                             .attr('cx', '50%').attr('cy', '50%').attr('r', '75%')
                             .call(function(radialGradient) {
                                 radialGradient.append('stop').attr('offset', '45%')
                                                              .attr('style', 'stop-color:rgb(155,155,155);stop-opacity:1');
                                 radialGradient.append('stop').attr('offset', '100%')
                                                              .attr('style', 'stop-color:rgb(75,75,75);stop-opacity:1');
                              });
// shadow blur filter
defs.append('filter').attr('id', 'shadow-blur')
                     .attr('x', -10).attr('y', -10).attr('width', 400).attr('height', 400)
                     .call(function(filter) {
                         filter.append('feOffset').attr('in', 'SourceAlpha')
                                                  .attr('result', 'offOut')
                                                  .attr('dx', 0).attr('dy', 6);
                         filter.append('feGaussianBlur').attr('in', 'offOut')
                                                        .attr('result', 'blurOut')
                                                        .attr('stdDeviation', '3 5');
                         filter.append('feBlend').attr('in', 'SourceGraphic')
                                                 .attr('in2', 'blurOut')
                                                 .attr('mode', 'normal');
                     });

// text emboss filter
defs.append('filter').attr('id', 'text-emboss')
                     .attr('x', -10).attr('y', -10).attr('width', 300).attr('height', 300)
                     .call(function(filter) {
                         filter.append('feFlood').attr('flood-color', '#757575')
                                                 .attr('result', 'color');
                         filter.append('feOffset').attr('in', 'SourceAlpha')
                                                  .attr('result', 'offOut')
                                                  .attr('dx', 0.5).attr('dy', 0);
                         filter.append('feComposite').attr('in', 'color')
                                                     .attr('in2', 'offOut')
                                                     .attr('operator', 'in');
                         filter.append('feBlend').attr('in', 'SourceGraphic')
                                                 .attr('mode', 'normal');
                     });

// button emboss filter
defs.append('filter').attr('id', 'button-emboss')
                     .attr('x', -10).attr('y', -0.5).attr('width', 300).attr('height', 300)
                     .call(function(filter) {
                         filter.append('feFlood').attr('flood-color', '#757575')
                                                 .attr('result', 'color');
                         filter.append('feOffset').attr('in', 'SourceAlpha')
                                                  .attr('result', 'offOut')
                                                  .attr('dx', -1).attr('dy', 0.5);
                         filter.append('feComposite').attr('in', 'color')
                                                     .attr('in2', 'offOut')
                                                     .attr('operator', 'in');
                         filter.append('feBlend').attr('in', 'SourceGraphic')
                                                 .attr('mode', 'normal');
                     });

return {

    edgePadding: { horizontal: 30, vertical: 20 },
    boxPadding:  { horizontal: 20, vertical: 30 },

    createCanvas: function(patch, parent) {
        var canvas = d3.select(_createSvgElement('g'))
                       .classed('rpd-patch', true);
        canvas.append(defs.node());
        canvas.append('rect').attr('width', '100%').attr('height', '100%')
                             .attr('fill', 'url(#blueprint)');
        return { element: canvas.node() };
    },

    createNode: function(node, render, description, icon) {

        var minContentSize = render.size ? { width: render.size.width || 70,
                                             height: render.size.height || 40 }
                                         : { width: 70, height: 40 };

        var pivot = render.pivot || { x: 0.5, y: 0.5 };

        function findBestNodeSize(numInlets, numOutlets, minContentSize) {
            var requiredContentHeight = (2 * socketsMargin) + ((Math.max(numInlets, numOutlets) - 1) * socketPadding);
            return { width: minContentSize.width,
                     height: headerHeight + Math.max(requiredContentHeight, minContentSize.height) };
        }

        var initialInlets = node.def.inlets,
            initialOutlets = node.def.outlets;

        var initialSize = findBestNodeSize(initialInlets  ? Object.keys(initialInlets).length  : 0,
                                           initialOutlets ? Object.keys(initialOutlets).length : 0,
                                           minContentSize);

        var longestInletLabel  = 0,
            longestOutletLabel = 0;

        if (initialInlets) {
            Object.keys(initialInlets).forEach(function(alias) {
                longestInletLabel = Math.max(longestInletLabel,
                    initialInlets[alias].label ? initialInlets[alias].label.length : alias.length);
            });
        }

        if (initialOutlets) {
            Object.keys(initialOutlets).forEach(function(alias) {
                longestOutletLabel = Math.max(longestOutletLabel,
                    initialOutlets[alias].label ? initialOutlets[alias].label.length : alias.length);
            });
        }

        var width = initialSize.width, height = initialSize.height;
        var bodyWidth = width,
            bodyHeight = height - headerHeight,
            inletsMargin = longestInletLabel * letterWidth,
            outletsMargin = longestOutletLabel * letterWidth,
            fullNodeWidth = inletsMargin + bodyWidth + outletsMargin;

        var nodeElm = d3.select(_createSvgElement('g')).attr('class', 'rpd-node');

        // append shadow
        nodeElm.append('path').attr('class', 'rpd-shadow')
                              //.attr('fill', 'url(#cyan-gradient)').attr('stroke', '#333').attr('stroke-width', 1.5)
                              .attr('fill', 'rgba(0,0,0,0.3)')
                              .attr('filter', 'url(#shadow-blur)')
                              .attr('d', roundedRect(0, 0, fullNodeWidth, headerHeight + bodyHeight, 6, 6, 6, 6));

        // append node header
        nodeElm.append('path').attr('class', 'rpd-header').classed('rpd-drag-handle', true)
                              .attr('fill', 'url(#gray-gradient)')
                              .attr('d', roundedRect(0, 0, fullNodeWidth, headerHeight, 6, 6, 0, 0));
        nodeElm.append('text').attr('class', 'rpd-name').text(node.def.title || node.type)
                              .attr('x', 7).attr('y', 12)
                              .attr('filter', 'url(#text-emboss)')
                              .style('pointer-events', 'none');
        // append node body
        nodeElm.append('path').attr('class', 'rpd-content')
                              .attr('fill', 'rgba(150,150,150,.5)')
                              .attr('d', roundedRect(0, headerHeight, fullNodeWidth, bodyHeight, 0, 0, 6, 6));
        nodeElm.append('rect').attr('class', 'rpd-body')
                              .attr('fill', 'transparent').attr('stroke', '#222').attr('stroke-width', 1.5)
                              .attr('width', fullNodeWidth).attr('height', height)
                              .attr('rx', 6).attr('ry', 6)
                              .style('pointer-events', 'none');

        // append tooltip with description
        nodeElm.select('.rpd-header')
               .append(_createSvgElement('title'))
               .text(description ? (description + ' (' + node.type + ')') : node.type);

        // append remove button
        nodeElm.append('g').attr('class', 'rpd-remove-button')
                           .attr('transform', 'translate(' + (fullNodeWidth-12) + ',1)')
               .call(function(button) {
                   button.append('path').attr('d', roundedRect(-1, 3, 9, 9, 2, 2, 2, 3))
                                        .attr('fill', 'transparent')
                                        .attr('class', 'rpd-remove-button-handle');
                   button.append('text').text('x').attr('x', 2).attr('y', 8)
                                        .style('pointer-events', 'none');
               });

        // append placeholders for inlets, outlets and a target element to render body into
        nodeElm.append('g').attr('class', 'rpd-inlets').attr('transform', 'translate(' + 0 + ',' + headerHeight + ')')
                                                       .data({ position: { x: 0, y: headerHeight } });
        nodeElm.append('g').attr('class', 'rpd-process').attr('transform', 'translate(' + (inletsMargin + (pivot.x * width)) + ','
                                                                                        + (headerHeight + ((height - headerHeight) * pivot.y)) + ')');
        nodeElm.append('g').attr('class', 'rpd-outlets').attr('transform', 'translate(' + fullNodeWidth + ',' + headerHeight + ')')
                                                        .data({ position: { x: width, y: headerHeight } });

        nodeElm.classed('rpd-'+node.type.slice(0, node.type.indexOf('/'))+'-toolkit-node', true)
               .classed('rpd-'+node.type.replace('/','-'), true);

        var numInlets = 0, numOutlets = 0;
        var inletElms = [], outletElms = [];
        var lastSize = initialSize;

        function checkNodeSize() {
            var curSize = lastSize;
            var newSize = findBestNodeSize(numInlets, numOutlets, minContentSize);
            if ((newSize.width === curSize.width) && (newSize.height === curSize.height)) return;
            inletsMargin = longestInletLabel * letterWidth;
            outletsMargin = longestOutletLabel * letterWidth;
            fullNodeWidth = inletsMargin + newSize.width + outletsMargin;
            nodeElm.select('path.rpd-header').attr('d', roundedRect(0, 0, fullNodeWidth, headerHeight, 6, 6, 0, 0));
            nodeElm.select('g.rpd-remove-button').attr('transform', 'translate(' + (fullNodeWidth-12) + ',1)');
            nodeElm.select('path.rpd-shadow').attr('d', roundedRect(0, 0, fullNodeWidth, newSize.height, 6, 6, 6, 6));
            nodeElm.select('rect.rpd-body').attr('height', newSize.height).attr('width', fullNodeWidth);
            nodeElm.select('path.rpd-content').attr('d', roundedRect(0, headerHeight,
                fullNodeWidth, newSize.height - headerHeight, 0, 0, 6, 6));
            nodeElm.select('g.rpd-process').attr('transform', 'translate(' + (inletsMargin + (pivot.x * newSize.width)) + ','
                                                                           + (headerHeight + ((newSize.height - headerHeight) * pivot.y)) + ')');
            nodeElm.select('g.rpd-outlets').attr('transform', 'translate(' + fullNodeWidth + ',' + headerHeight + ')');
            lastSize = newSize;
        }

        function recalculateSockets() {
            inletElms.forEach(function(inletElm, idx) {
                var inletPos = findInletPos(idx);
                inletElm.attr('transform',  'translate(' + inletPos.x + ',' + inletPos.y + ')');
                //inletElm.data().position = inletPos;
            });
            outletElms.forEach(function(outletElm, idx) {
                var outletPos = findOutletPos(idx);
                outletElm.attr('transform',  'translate(' + outletPos.x + ',' + outletPos.y + ')');
                //outletElm.data().position = outletPos;
            });
        }

        function notifyNewInlet(elm, inlet) {
            longestInletLabel = Math.max(longestInletLabel, inlet.label ? inlet.label.length : inlet.alias.length);
            numInlets++; inletElms.push(elm); checkNodeSize();
            recalculateSockets();
        }

        function notifyNewOutlet(elm, outlet) {
            longestOutletLabel = Math.max(longestOutletLabel, outlet.label ? outlet.label.length : outlet.alias.length);
            numOutlets++; outletElms.push(elm); checkNodeSize();
            recalculateSockets();
        }

        function findInletPos(idx) { // index from top to down for Quartz mode, or left to right for PD mode
            if (numInlets >= numOutlets) {
                return { x: 0, y: socketsMargin + (socketPadding * idx) };
            } else {
                var fullSide = (2 * socketsMargin) + (numOutlets - 1) * socketPadding;
                return { x: 0, y: (fullSide / 2) + (((-1 * (numInlets - 1)) / 2) + idx) * socketPadding };
            }
        }

        function findOutletPos(idx) { // index from top to down for Quartz mode, or left to right for PD mode
            if (numOutlets >= numInlets) {
                return { x: 0, y: socketsMargin + (socketPadding * idx) };
            } else {
                var fullSide = (2 * socketsMargin) + (numInlets - 1) * socketPadding;
                return { x: 0, y: (fullSide / 2) + (((-1 * (numOutlets - 1)) / 2) + idx) * socketPadding };
            }
        }

        listeners[node.id] = {
            inlet: notifyNewInlet,
            outlet: notifyNewOutlet
        };

        return {
            element: nodeElm.node(),
            size: initialSize
        };

    },

    createInlet: function(inlet, render) {
        var inletElm = d3.select(_createSvgElement('g')).attr('class', 'rpd-inlet');
        inletElm.call(function(group) {
            //group.attr('transform', 'translate(' + inletPos.x + ',' + inletPos.y + ')')
            group.append('circle').attr('class', 'rpd-connector')
                                  .attr('fill', '#999').attr('stroke', '#333').attr('stroke-width', 1)
                                  .attr('cx', 0).attr('cy', 0).attr('r', 4);
            group.append('g').attr('class', 'rpd-value-holder')
                 .attr('transform', 'translate(-8,0)')
                 .attr('text-anchor', 'end')
                 .append('text').attr('class', 'rpd-value').attr('fill', '#999');
            group.append('text').attr('class', 'rpd-name').text(inlet.def.label || inlet.alias)
                                .attr('x', 10).attr('y', 0)
                                .attr('filter', 'url(#text-emboss)');
        });
        listeners[inlet.node.id].inlet(inletElm, inlet);
        inletToConnector[inlet.id] = inletElm.select('.rpd-connector');
        return { element: inletElm.node() };
    },

    createOutlet: function(outlet, render) {
        var outletElm = d3.select(_createSvgElement('g')).attr('class', 'rpd-outlet');
        outletElm.call(function(group) {
            //group.attr('transform', 'translate(' + outletPos.x + ',' + outletPos.y + ')')
            group.append('circle').attr('class', 'rpd-connector')
                                  .attr('fill', '#999').attr('stroke', '#333').attr('stroke-width', 1)
                                  .attr('cx', 0).attr('cy', 0).attr('r', 4);
            group.append('g').attr('class', 'rpd-value-holder')
                 .append('text').attr('class', 'rpd-value').attr('fill', '#999')
                                .attr('x', 10).attr('y', 0)
                                .style('pointer-events', 'none');
            group.append('text').attr('class', 'rpd-name').text(outlet.def.label || outlet.alias)
                                .attr('x', -10).attr('y', 0)
                                .attr('filter', 'url(#text-emboss)');
        });
        listeners[outlet.node.id].outlet(outletElm, outlet);
        outletToConnector[outlet.id] = outletElm.select('.rpd-connector');
        return { element: outletElm.node() };
    },

    createLink: function(link) {
        var linkElm = d3.select(_createSvgElement(
                            (config.linkForm && (config.linkForm == 'curve')) ? 'path' : 'line'
                        )).attr('class', 'rpd-link')
                          .attr('fill', 'transparent')
                          .attr('stroke', 'lightgray')
                          .attr('stroke-width', 2);
        return { element: linkElm.node(),
                 rotate: function(x0, y0, x1, y1) {
                     if (config.linkForm && (config.linkForm == 'curve')) {
                        linkElm.attr('d', bezierByH(x0, y0, x1, y1));
                    } else {
                        linkElm.attr('x1', x0).attr('y1', y0)
                               .attr('x2', x1).attr('y2', y1);
                    }
                 },
                 noPointerEvents: function() {
                     linkElm.style('pointer-events', 'none');
                 } };
    },

    getInletPos: function(inlet) {
        var connectorPos = getPos(inletToConnector[inlet.id].node());
        return { x: connectorPos.x + 5, y: connectorPos.y + 5 };
    },

    getOutletPos: function(outlet) {
        var connectorPos = getPos(outletToConnector[outlet.id].node());
        return { x: connectorPos.x + 5, y: connectorPos.y + 5 };
    },

    getLocalPos: function(pos) {
        if (!lastCanvas) return pos;
        // calculate once on patch switch?
        var canvasPos = getPos(lastCanvas.node());
        return { x: pos.x - canvasPos.x, y: pos.y - canvasPos.y };
    },

    onPatchSwitch: function(patch, canvas) {
        lastCanvas = d3.select(canvas);
    },

    onNodeRemove: function(node) {
        listeners[node.id] = null;
    }

};

function bezierByH(x0, y0, x1, y1) {
    var mx = x0 + (x1 - x0) / 2;

    return 'M' + x0 + ' ' + y0 + ' '
         + 'C' + mx + ' ' + y0 + ' '
               + mx + ' ' + y1 + ' '
               + x1 + ' ' + y1;
}

function roundedRect(x, y, width, height, rtl, rtr, rbr, rbl) {
    return "M" + x + "," + y
         + (rtl ? ("v" + rtl
                 + "a" + rtl + "," + rtl + " 0 0 1 " +  rtl + "," + -rtl) : "")
         + "h" + (width  - (rtl ? rtl : 0) - (rtr ? rtr : 0))
         + (rtr ? ("a" + rtr + "," + rtr + " 0 0 1 " +  rtr + "," +  rtr) : "")
         + "v" + (height - (rtr ? rtr : 0) - (rbr ? rbr : 0))
         + (rbr ? ("a" + rbr + "," + rbr + " 0 0 1 " + -rbr + "," +  rbr) : "")
         + "h" + ((rbr ? rbr : 0) + (rbl ? rbl : 0) - width)
         + (rbl ? ("a" + rbl + "," + rbl + " 0 0 1 " + -rbl + "," + -rbl) : "")
         + "v" + ((rbl ? rbl : 0) + (rtl ? rtl : 0) - height)
         + "z";
}

function getPos(elm) { var bounds = elm.getBoundingClientRect();
                       return { x: bounds.left, y: bounds.top } };

});

})(this);

;(function(global) {
  "use strict";

var Rpd = global.Rpd;
if (typeof Rpd === "undefined" && typeof require !== "undefined") {
    Rpd = require('rpd');
}

var ƒ = Rpd.unit;

var defaultConfig = {
    style: 'quartz',
    // network takes the full page, so the target element will be resized
    // to match browser window size when it was resized by user and so on
    fullPage: false,
    // show inlet/outlet value only when user hovers over its connector
    // (always showing, by default)
    valuesOnHover: false,
    // show node containers for debugging purposes
    showBoxes: false,
    // are nodes allowed to be dragged
    nodeMovingAllowed: true,
    // only one connection is allowed to inlet by default
    inletAcceptsMultipleLinks: false,
    // when user opens a projected sub-patch, automatically close its parent patch
    closeParent: false,
    // write global errors to console, if it exists
    logErrors: true,
    // a time for value update or error effects on inlets/outlets
    effectTime: 1000
};

// either use the full d3.js library or the super-tiny version provided with RPD
var d3 = d3 || d3_tiny;

var Render = Rpd.Render; // everything common between renderers

var tree = {
    patches: {},
    nodes: {},
    inlets: {},
    outlets: {},
    links: {},

    patchToPlacing: {},
    patchToLinks: {},
    nodeToLinks: {}
};

var currentPatch;

var nodeTypes = Rpd.allNodeTypes,
    nodeDescriptions = Rpd.allNodeDescriptions,
    nodeTypeIcons = Rpd.allNodeTypeIcons;

function _createSvgElement(name) {
    return document.createElementNS(d3.ns.prefix.svg, name);
}

function SvgRenderer(patch) {

return function(networkRoot, userConfig) {

    var config = mergeConfig(userConfig, defaultConfig);

    // FIXME: should be called once when renderer is
    // registered and Rpd.events is ready, not for every patch
    Render.reportErrorsToConsole(config);

    var style = Rpd.getStyle(config.style, 'svg')(config);

    networkRoot = d3.select(networkRoot)
                    .classed('rpd-network', true)
                    .classed('rpd-full-page', config.fullPage);

    var svg;
    /* a.k.a. patch canvas, but not obligatory HTML5 canvas */

    var connectivity, dnd;

    return {

        // the object below reacts on every Patch event and constructs corresponding
        // HTML structures in response, or modifies them;

        'patch/is-ready': function(update) {

            var docElm = d3.select(document.documentElement);

            // build canvas element as a target for all further patch modifications
            svg = d3.select(_createSvgElement('svg'))
                    .attr('width', networkRoot.property('clientWidth'))
                    .attr('height', networkRoot.property('clientHeight'))
                    .classed('rpd-canvas', true);

            svg.append('rect').attr('class', 'rpd-background');

            if (config.fullPage) {
                svg.attr('width', '100%'/*docElm.property('clientWidth')*/)
                   .attr('height', docElm.property('clientHeight'));
                svg.select('.rpd-background').attr('width', '100%'/*docElm.property('clientWidth')*/)
                                             .attr('height', docElm.property('clientHeight'));
            }

            var patchCanvas = svg.append(style.createCanvas(patch, networkRoot).element)
                               .classed('rpd-style-' + config.style, true)
                               .classed('rpd-values-' + (config.valuesOnHover ? 'on-hover' : 'always-shown'), true)
                               .classed('rpd-show-boxes', config.showBoxes)
                               .data(update.patch);

            tree.patches[patch.id] = svg.data({ canvas: patchCanvas,
                                                width: docElm.property('clientWidth'),
                                                height: docElm.property('clientHeight'),
                                                patch: update.patch
                                              });

            // resize network root on window resize
            if (config.fullPage) updateCanvasHeightOnResize(window, document, svg, svg.select('.rpd-background'));

            // initialize the node placing (helps in determining the position where new node should be located)
            tree.patchToPlacing[patch.id] = new Render.Placing(style);
            tree.patchToLinks[patch.id] = new VLinks();

            // initialize connectivity module, it listens for clicks on outlets and inlets and builds or removes
            // links if they were clicked in the appropriate order
            connectivity = new /*Render.*/Connectivity(svg, style, config);

            // initialized drag-n-drop support (used to allow user drag nodes)
            if (config.nodeMovingAllowed) dnd = new Render.DragAndDrop(svg, style);

            Kefir.fromEvents(svg.node(), 'selectstart').onValue(preventDefault);

        },

        'patch/open': function(update) {
            if ((config.closeParent || config.fullPage) && update.parent) update.parent.close();
            currentPatch = update.patch;
            var newCanvas = tree.patches[update.patch.id];
            networkRoot.append(newCanvas.node());

            tree.patchToLinks[update.patch.id].updateAll();
            if (style.onPatchSwitch) style.onPatchSwitch(currentPatch, newCanvas.node());
        },

        'patch/close': function(update) {
            currentPatch = null;
            svg.remove();
        },

        'patch/refer': function(update) {
            var node = update.node;

            var nodeBox = tree.nodes[node.id];

            nodeBox.select('.rpd-node').classed('rpd-patch-reference', true);
            nodeBox.data().processTarget.append(_createSvgElement('text'))
                                                .text('[' + (update.target.name || update.target.id) + ']');

            // add the ability to enter the patch by clicking node body (TODO: move to special node type)
            Kefir.fromEvents(nodeBox.data().processTarget.node(), 'click')
                 .onValue((function(current, target) {
                    return function() {
                        target.open(current);
                    }
                 })(patch, update.target));
        },

        'patch/move-canvas': function(update) {
            svg.style('position', 'relative');
            svg.style('top', Math.floor(update.position[0]) + 'px');
            svg.style('left', Math.floor(update.position[1]) + 'px');
            //svg.attr('transform', 'translate(' + Math.floor(update.position[0]) + ',' + Math.floor(update.position[1]) + ')');
        },

        'patch/resize-canvas': function(update) {
            svg.attr('width', update.size[0]);
            svg.attr('height', update.size[1]);
            svg.select('.rpd-background').attr('width', '100%')
                                         .attr('height', '100%');
        },

        'patch/add-node': function(update) {

            var node = update.node;

            var render = update.render;

            // find a rectange to place the new node
            var placing = tree.patchToPlacing[update.patch.id],
                // current patch canvas should be used as a limit source, even if we add to another patch
                // or else other canvas may have no dimensions yet
                limitSrc = tree.patches[currentPatch.id].data();

            var nodeBox = d3.select(_createSvgElement('g')).attr('class', 'rpd-node-box');
            var styledNode = style.createNode(node, render, nodeDescriptions[node.type], nodeTypeIcons[node.type]);
            var nodeElm = nodeBox.append(styledNode.element);

            // store targets information and node canvas element itself
            tree.nodes[node.id] = nodeBox.data({ inletsTarget:  nodeElm.select('.rpd-inlets'),
                                                 outletsTarget: nodeElm.select('.rpd-outlets'),
                                                 processTarget: nodeElm.select('.rpd-process'),
                                                 position: nodePos, size: styledNode.size });

            var nodePos = placing.nextPosition(node, styledNode.size, { width: limitSrc.width, height: limitSrc.height });

            node.move(nodePos.x, nodePos.y);

            var nodeLinks = new VLinks();
            tree.nodeToLinks[node.id] = nodeLinks;

            // add possiblity to drag nodes
            if (config.nodeMovingAllowed) {
                var shadow = nodeElm.select('.rpd-shadow'),
                    handle = nodeElm.select('.rpd-drag-handle');
                if (!handle.empty()) {
                    dnd.add(handle,
                        { start: function() {
                            nodeElm.classed('rpd-dragging', true);
                            if (!shadow.empty()) shadow.attr('x', 7).attr('y', 8);
                            return nodeBox.data().position;
                          },
                          drag: function(pos) {
                              nodeBox.attr('transform', 'translate(' + pos.x + ',' + pos.y + ')');
                              nodeLinks.forEach(function(vlink) { vlink.update(); });
                          },
                          end: function(pos) {
                              node.move(pos.x, pos.y);
                              if (!shadow.empty()) shadow.attr('x', 5).attr('y', 6);
                              nodeElm.classed('rpd-dragging', false);
                          }
                      });
                }
            }

            // node could require some preparation using patch cavas
            if (render.prepare) render.prepare.bind(node)
                                              (tree.patches[patch.id].node(),
                                               tree.patches[currentPatch.id].node());

            // use custom node body renderer, if defined
            if (render.first) subscribeUpdates(node, render.first.bind(node)(nodeElm.select('.rpd-process').node(), node.event['node/configure']));

            // if node body should be re-rendered, update links (since body element bounds could change)
            if (render.always) {
                // this code used getBoundingClientRect to determine if node body width/height
                // values were changed and updates links positions only when they really did,
                // but it appeared to be quite hard to check, i.e. height value, since browsers
                // keep it equal to 0
                node.event['node/process'].throttle(100).onValue(function() {
                    nodeLinks.updateAll();
                });
            }

            // remove node when remove button was clicked
            var removeButton = nodeElm.select('.rpd-remove-button');
            if (!removeButton.empty()) {
                Kefir.fromEvents(nodeElm.select('.rpd-remove-button-handle').node(), 'click')
                     .map(stopPropagation)
                     .onValue(function() {
                         patch.removeNode(node);
                     });
            }

            // append to the the patch canvas node
            var patchCanvas = tree.patches[node.patch.id].data().canvas;
            patchCanvas.append(nodeBox.node());

        },

        'patch/remove-node': function(update) {
            var node = update.node;

            var nodeBox = tree.nodes[node.id];

            tree.nodeToLinks[node.id].forEach(function(vlink) {
                vlink.get().disconnect();
            });

            nodeBox.remove();
            if (style.onNodeRemove) style.onNodeRemove(node);

            tree.nodes[node.id] = null; // no updates will fire from this node,
                                        // so it's just to avoid holding memory for it
            tree.nodeToLinks[node.id] = null;

        },

        'node/move': function(update) {
            var nodeBox = tree.nodes[update.node.id];
            var position = update.position;
            nodeBox.attr('transform', 'translate(' + Math.floor(position[0]) + ',' + Math.floor(position[1]) + ')');
            nodeBox.data().position = { x: position[0], y: position[1] };
        },

        'node/process': function(update) {
            var node = update.node;
            var render = update.render;

            // update node body with custom renderer, if defined
            if (render.always) {
                var bodyElm = tree.nodes[node.id].data().processTarget.node();
                render.always.bind(node)(bodyElm, update.inlets, update.outlets);
            }
        },

        'node/add-inlet': function(update) {

            var inlet = update.inlet;

            if (inlet.def.hidden) return;

            var nodeData = tree.nodes[update.node.id].data();

            var inletsTarget = nodeData.inletsTarget;
            var render = update.render;

            var inletElm;

            var inletElm = d3.select(style.createInlet(inlet, render).element);

            inletElm.classed('rpd-'+inlet.type.replace('/','-'), true);
            inletElm.classed({ 'rpd-stale': true,
                               'rpd-readonly': inlet.def.readonly || false,
                               'rpd-cold': inlet.def.cold || false
                             });

            var editor = null;
            if (!inlet.def.readonly && render.edit) {
                editor = new ValueEditor(inlet, render, svg,
                                         inletElm.select('.rpd-value-holder'),
                                         inletElm.select('.rpd-value'),
                                         d3.select(_createSvgElement('g')));
                inletElm.select('.rpd-value-holder').append(editor.editorElm.node());
            }

            tree.inlets[inlet.id] = inletElm.data({
                connector: inletElm.select('.rpd-connector'),
                value: inletElm.select('.rpd-value'),
                vlinks: new VLinks(), // links associated with this inlet
                editor: editor
                //position: inletPos
            });

            // adds `rpd-error` CSS class and removes it by timeout
            inlet.event['inlet/update'].onError(function() {
                addValueErrorEffect(inlet.id, inletElm, config.effectTime);
            });

            // listen for clicks in connector and allow to edit links this way
            connectivity.subscribeInlet(inlet, inletElm.select('.rpd-connector'));

            inletsTarget.append(inletElm.node());
        },

        'node/add-outlet': function(update) {

            var outlet = update.outlet;

            var nodeData = tree.nodes[update.node.id].data();

            var outletsTarget = nodeData.outletsTarget;
            var render = update.render;

            var outletElm = d3.select(style.createOutlet(outlet, render).element);

            outletElm.classed('rpd-'+outlet.type.replace('/','-'), true);
            outletElm.classed('rpd-stale', true);

            tree.outlets[outlet.id] = outletElm.data({
                connector: outletElm.select('.rpd-connector'),
                value: outletElm.select('.rpd-value'),
                vlinks: new VLinks() // links associated with this outlet
                //position: outletPos
            });

            // listen for clicks in connector and allow to edit links this way
            connectivity.subscribeOutlet(outlet, outletElm.select('.rpd-connector'));

            outletsTarget.append(outletElm.node());
        },

        'node/remove-inlet': function(update) {
            var inlet = update.inlet;
            var inletData = tree.inlets[inlet.id].data();

            inletData.vlinks.forEach(function(vlink) {
                vlink.get().disconnect();
            });

            tree.inlets[inlet.id].remove();
            if (style.onInletRemove) style.onInletRemove(inlet);

            tree.inlets[inlet.id] = null;

        },

        'node/remove-outlet': function(update) {
            var outlet = update.outlet;
            var outletData = tree.outlets[outlet.id].data();

            outletData.vlinks.forEach(function(vlink) {
                vlink.get().disconnect();
            });

            tree.outlets[outlet.id].remove();
            if (style.onOutletRemove) style.onOutletRemove(outlet);

            tree.outlets[outlet.id] = null;
        },

        'inlet/update': function(update) {

            var inlet = update.inlet;

            if (inlet.def.hidden) return;

            var render = update.render;

            var inletElm = tree.inlets[inlet.id];
            var valueElm = inletElm.data().value;

            if (!valueElm.empty()) {
                var valueRepr = inlet.def.show ? inlet.def.show(update.value)
                                               : update.value;
                if (render.show) {
                    render.show.bind(inlet)(valueElm.parent().node(), update.value, valueRepr);
                } else {
                    valueElm.text(valueRepr);
                }
            }

            // adds `rpd-fresh` CSS class and removes it by timeout
            addValueUpdateEffect(inlet.id, inletElm, config.effectTime);

        },

        'outlet/update': function(update) {

            var outlet = update.outlet;
            var render = update.render;

            var outletElm = tree.outlets[outlet.id];
            var valueElm = outletElm.data().value;

            if (!valueElm.empty()) {
                var valueRepr = outlet.def.show ? outlet.def.show(update.value)
                                                : update.value;
                if (render.show) {
                    render.show.bind(outlet)(valueElm.parent().node(), update.value, valueRepr);
                } else {
                    valueElm.text(valueRepr);
                }
            }

            // adds `rpd-fresh` CSS class and removes it by timeout
            addValueUpdateEffect(outlet.id, outletElm, config.effectTime);

        },

        'outlet/connect': function(update) {

            var link   = update.link;
            var outlet = link.outlet;
            var inlet  = link.inlet;

            var outletElm = tree.outlets[outlet.id];
            var inletElm  = tree.inlets[inlet.id];

            var outletData = outletElm.data();
            var inletData  = inletElm.data();

            if (!config.inletAcceptsMultipleLinks && (inletData.vlinks.count() === 1)) {
                throw new Error('Inlet is already connected to a link');
            }

            // disable value editor when connecting to inlet
            if (inletData.editor) inletData.editor.disable();

            var vlink = new VLink(link, style);

            vlink.construct(config.linkWidth)
                 .rotateOI(outlet, inlet);

            d3.select(vlink.getElement())
              .classed('rpd-'+inlet.type.replace('/','-'), true)
              .classed('rpd-'+outlet.type.replace('/','-'), true)

            tree.links[link.id] = vlink;
            outletData.vlinks.add(vlink);
            inletData.vlinks.add(vlink);

            tree.nodeToLinks[outlet.node.id].add(vlink);
            if (outlet.node.id !== inlet.node.id) {
                tree.nodeToLinks[inlet.node.id].add(vlink);
            }
            tree.patchToLinks[patch.id].add(vlink);

            vlink.listenForClicks();

            vlink.appendTo(svg);

        },

        'outlet/disconnect': function(update) {

            var link = update.link;
            var vlink = tree.links[link.id];

            var outlet = link.outlet;
            var inlet  = link.inlet;

            var outletData = tree.outlets[outlet.id].data();
            var inletData  = tree.inlets[inlet.id].data();

            // forget all references
            tree.links[link.id] = null;
            outletData.vlinks.remove(vlink);
            inletData.vlinks.remove(vlink);

            tree.nodeToLinks[outlet.node.id].remove(vlink);
            if (outlet.node.id !== inlet.node.id) {
                tree.nodeToLinks[inlet.node.id].remove(vlink);
            }
            tree.patchToLinks[patch.id].remove(vlink);

            // remove link element
            vlink.removeFrom(svg);

        },

        'link/enable': function(update) {
            var inlet = update.link.inlet;
            var inletData  = tree.inlets[inlet.id].data();
            if (inletData.editor) inletData.editor.disable();

            tree.links[update.link.id].enable();
        },

        'link/disable': function(update) {
            tree.links[update.link.id].disable();
        }

    }

} // function(target, config)

} // function(patch)

function patchByHash(tree) {
    return function(hash) {
        return tree.patches[hash].data().patch;
    }
}

function updateCanvasHeightOnResize(_window, _document, svg, background) {
    // resize canvas element on window resize
    Kefir.fromEvents(_window, 'resize')
         .map(function() { return _window.innerHeight ||
                                  _document.documentElement.clientHeight ||
                                  _document.body.clientHeight; })
         .onValue(function(value) {
             svg.attr('height', value);
             background.attr('height', value);
             svg.data().height = value;
         });
    svg.data().subscribedToResize = true;
}

// =============================================================================
// ============================= Connectivity ==================================
// =============================================================================

function awaiting(a, b) {
    return Kefir.merge([ a.map(ƒ(true)),
                         b.map(ƒ(false)) ]).toProperty(ƒ(false));
}

// FRP-based connection (links b/w outlets and inlets) editor logic

var Connectivity = (function() {

    function getLinks(inlet) {
        return tree.inlets[inlet.id].data().vlinks;
    }
    function hasLinks(inlet) {
        return function() {
            return (getLinks(inlet).count() > 0);
        }
    }
    function getConnector(outlet) {
        return tree.outlets[outlet.id].data().connector;
    }
    function removeExistingLink(inletLinks) {
        if (inletLinks.count() === 1) {
            // cases when .count() > 1 should never happen in this case
            var prevLink = inletLinks.getLast().link,
                otherOutlet = prevLink.outlet;
            otherOutlet.disconnect(prevLink);
        }
    }
    function removeConnectionsToOutlet(inletLinks, outlet) {
        inletLinks.forEach(function(vlink) {
            if (vlink.link.outlet.id === outlet.id) {
                outlet.disconnect(vlink.link);
            }
        });
    }

    function Connectivity(canvas, style, config) {
        this.canvas = canvas;
        this.style = style;
        this.config = config;

        this.canvasClicks = Kefir.fromEvents(this.canvas.node(), 'click');
        this.inletClicks = Kefir.pool(),
        this.outletClicks = Kefir.pool();

        this.startLink = Kefir.emitter(),
        this.finishLink = Kefir.emitter(),
        this.doingLink = awaiting(this.startLink, this.finishLink);
    }
    Connectivity.prototype.subscribeOutlet = function(outlet, connector) {

        var canvas = this.canvas; var style = this.style; var config = this.config;
        var canvasClicks = this.canvasClicks, outletClicks = this.outletClicks, inletClicks = this.inletClicks;
        var startLink = this.startLink, finishLink = this.finishLink, doingLink = this.doingLink;

        // - Every time user clicks an outlet, a new link is created which user can drag, then:
        // - If user clicks other outlet after that, linking process is cancelled;
        // - If user clicks canvas element, linking process is cancelled;
        // - If user clicks an inlet, linking process is considered successful and finished, but also...
        // - If this inlet had a link there connected, this previous link is removed and disconnected;

        outletClicks.plug(Kefir.fromEvents(connector.node(), 'click')
                               .map(extractPos)
                               .map(addTarget(outlet)));

        Kefir.fromEvents(connector.node(), 'click')
             .map(stopPropagation)
             .filterBy(awaiting(outletClicks, doingLink))
             .map(extractPos)
             .onValue(function(pos) {
                 startLink.emit();
                 var ghost = new VLink(null, style).construct(config.linkWidth)
                                                   .rotateO(outlet, pos.x, pos.y)
                                                   .noPointerEvents().appendTo(canvas);
                 d3.select(ghost.getElement())
                   .classed('rpd-'+outlet.type.replace('/','-'), true);
                 Kefir.fromEvents(canvas.node(), 'mousemove')
                      .takeUntilBy(Kefir.merge([ inletClicks,
                                                 outletClicks.map(ƒ(false)),
                                                 canvasClicks.map(ƒ(false)) ])
                                        .take(1)
                                        .onValue(function(success) {
                                            if (!success) return;
                                            var inlet = success.target,
                                                inletLinks = getLinks(inlet);
                                            if (config.inletAcceptsMultipleLinks) {
                                                removeConnectionsToOutlet(inletLinks, outlet);
                                            } else { removeExistingLink(inletLinks); }
                                            outlet.connect(inlet);
                                        }))
                      .map(extractPos)
                      .onValue(function(pos) {
                          ghost.rotateO(outlet, pos.x, pos.y);
                      }).onEnd(function() {
                          ghost.removeFrom(canvas);
                          finishLink.emit();
                      });
             });

    };
    Connectivity.prototype.subscribeInlet = function(inlet, connector) {

        var canvas = this.canvas; var style = this.style; var config = this.config;
        var canvasClicks = this.canvasClicks, outletClicks = this.outletClicks, inletClicks = this.inletClicks;
        var startLink = this.startLink, finishLink = this.finishLink, doingLink = this.doingLink;

        // - Every time user clicks an inlet which has a link there connected:
        // - This link becomes editable and so can be dragged by user,
        // - If user clicks outlet after that, linking process is cancelled and this link is removed;
        // - If user clicks canvas element after that, linking process is cancelled,
        //   and this link is removed;
        // - If user clicks other inlet, the link user drags/edits now is moved to be connected
        //   to this other inlet, instead of first-clicked one;

        inletClicks.plug(Kefir.fromEvents(connector.node(), 'click')
                              .map(extractPos)
                              .map(addTarget(inlet)));

        Kefir.fromEvents(connector.node(), 'click')
             .map(stopPropagation)
             .filterBy(awaiting(inletClicks, doingLink))
             .filter(hasLinks(inlet))
             .onValue(function(pos) {
                 var lastLink = getLinks(inlet).getLast().link;
                 var outlet = lastLink.outlet;
                 outlet.disconnect(lastLink);
                 startLink.emit();
                 var ghost = new VLink(null, style).construct(config.linkWidth)
                                                   .rotateO(outlet, pos.x, pos.y)
                                                   .noPointerEvents().appendTo(canvas);
                 d3.select(ghost.getElement())
                   .classed('rpd-'+inlet.type.replace('/','-'), true)
                   .classed('rpd-'+outlet.type.replace('/','-'), true);
                 Kefir.fromEvents(canvas.node(), 'mousemove')
                      .takeUntilBy(Kefir.merge([ inletClicks,
                                                 outletClicks.map(ƒ(false)),
                                                 canvasClicks.map(ƒ(false)) ])
                                        .take(1)
                                        .onValue(function(success) {
                                            if (!success) return;
                                            var otherInlet = success.target,
                                                otherInletLinks = getLinks(otherInlet);
                                            if (config.inletAcceptsMultipleLinks) {
                                                removeConnectionsToOutlet(otherInletLinks, outlet);
                                            } else { removeExistingLink(otherInletLinks); }
                                            outlet.connect(otherInlet);
                                        }))
                      .map(extractPos)
                      .onValue(function(pos) {
                          ghost.rotateO(outlet, pos.x, pos.y);
                      }).onEnd(function() {
                          ghost.removeFrom(canvas);
                          finishLink.emit();
                      });
             });

    };

    return Connectivity;

})();

// =============================================================================
// =============================== Values ======================================
// =============================================================================

function ValueEditor(inlet, render, canvas, valueHolder, valueElm, editorElm) {
    var valueIn = Kefir.emitter(),
        disableEditor = Kefir.emitter();
    this.disableEditor = disableEditor;
    this.editorElm = editorElm;
    this.valueElm = valueElm;
    editorElm.classed('rpd-value-editor', true);
    var valueOut = render.edit.bind(inlet)(editorElm.node(), inlet, valueIn);
    valueOut.onValue(function(value) { inlet.receive(value); });
    Kefir.combine([ Kefir.merge([
                              Kefir.fromEvents(valueHolder.node(), 'click')
                                   .map(stopPropagation)
                                   .map(ƒ(true)),
                              Kefir.fromEvents(canvas.node(), 'click')
                                   .merge(disableEditor)
                                   .map(ƒ(false)) ])
                         .toProperty(ƒ(false))
                         .skipDuplicates() ],
                  [ inlet.event['inlet/update'] ])
         .map(function(val) { return { lastValue: val[1],
                                       startEditing: val[0],
                                       cancelEditing: !val[0] }; })
         .onValue(function(conf) {
            if (conf.startEditing) {
                var inletData = tree.inlets[inlet.id].data();
                if (inletData.link) inletData.link.disable();
                valueIn.emit(conf.lastValue);
                valueHolder.classed('rpd-editor-enabled', true);
                valueHolder.classed('rpd-editor-disabled', false);
            } else if (conf.cancelEditing) {
                valueElm.classed('rpd-edited', true);
                valueHolder.classed('rpd-editor-enabled', false);
                valueHolder.classed('rpd-editor-disabled', true);
            }
         });
    valueHolder.classed('rpd-editor-enabled', false);
    valueHolder.classed('rpd-editor-disabled', true);
}
ValueEditor.prototype.disable = function() {
    this.valueElm.classed('rpd-edited', false);
    this.disableEditor.emit();
}

// =============================================================================
// =============================== helpers =====================================
// =============================================================================

var VLink  = Render.VLink,
    VLinks = Render.VLinks;

var mergeConfig = Render.mergeConfig;

var preventDefault = Render.preventDefault,
    stopPropagation = Render.stopPropagation;

var extractPos = Render.extractPos;

var addTarget = Render.addTarget,
    addClickSwitch = Render.addClickSwitch;

var addValueErrorEffect = Render.addValueErrorEffect,
    addValueUpdateEffect = Render.addValueUpdateEffect;

var subscribeUpdates = Render.subscribeUpdates;

// =============================================================================
// ============================ registration ===================================
// =============================================================================

Rpd.SvgRenderer = SvgRenderer;

Rpd.renderer('svg', SvgRenderer);

})(this);

var RpdUtils = (function() {

function adaptToState(state, value) {
    return Math.floor((state.min + ((state.max - state.min) * value)) * 100) / 100;
}

function numberToHex(num) { return (num > 15) ? num.toString(16) : '0' + num.toString(16); }

function toHexColor(color) {
    return '#' + numberToHex(color.r || 0)
               + numberToHex(color.g || 0)
               + numberToHex(color.b || 0);
}

function getNodeTypesByToolkit(nodeTypes) {
    return Object.keys(nodeTypes).reduce(function(byToolkit, nodeType) {
        var slashPos = nodeType.indexOf('/');
        var toolkit = (slashPos < 0) ? toolkit : nodeType.substring(0, slashPos);
        var typeName = (slashPos < 0) ? '' : nodeType.substring(slashPos + 1);
        if (!byToolkit[toolkit]) byToolkit[toolkit] = { icon: '', types: [] };
        byToolkit[toolkit].types.push({ toolkit: toolkit,
                                        fullName: nodeType, name: typeName,
                                        data: nodeTypes[nodeType] });
        return byToolkit;
    }, {})
}

function NodeList(conf) {
    this.listElements = [];

    this.selected = null;

    this.markSelected = conf.markSelected;
    this.markDeselected = conf.markDeselected;
    this.markAdding = conf.markAdding;
    this.markAdded = conf.markAdded;
    this.recalculateSize = conf.recalculateSize;

    this.setVisible = conf.setVisible;
    this.setInvisible = conf.setInvisible;

    this.getPatch = conf.getPatch;

    // create text input, search field, to let user filter results
    this.searchInput = conf.createSearchInput();
    // create a button which is able to clear this field
    this.clearSearchButton = conf.createClearSearchButton();

    var listElements = conf.buildList();

    var search = this.searchInput,
        clearSearch = this.clearSearchButton;

    this.clearingEvents = Kefir.fromEvents(this.clearSearchButton.node(), 'click')
        .onValue(function() {
            this.selectNothing();
            conf.clearSearchInput(this.searchInput);
        }.bind(this));

    // make the list of elements double-linked and looped,
    // so easy navigation with up/down arrow keys will be possible
    for (var i = 0; i < listElements.length; i++) {
        listElements[i].visible = true;
        listElements[i].prev = (i > 0) ? listElements[i - 1] : listElements[listElements.length - 1];
        listElements[i].next = (i < listElements.length - 1) ? listElements[i + 1] : listElements[0];
    }

    this.listElements = listElements;

    this.currentlyVisible = listElements.length;
}

NodeList.prototype.select = function(elmData) {
    if (this.selected) this.markDeselected(this.selected);
    this.selected = elmData;
    if (this.selected) this.markSelected(elmData);
}

NodeList.prototype.selectNothing = function() {
    this.select(null);
}

NodeList.prototype.addOnClick = function() {
    var nodeList = this;

    var listElements = this.listElements;

    listElements.forEach(function(elmData) {
        var li = elmData.element;
        Kefir.fromEvents(li.node(), 'click')
             .onValue(function() {
                 // add the node when corresponding element was clicked with mouse
                 nodeList.select(elmData);
                 nodeList.addNode(elmData);
             });
    });

}

NodeList.prototype.addNode = function(elmData) {
    this.markAdding(elmData);
    setTimeout(function() {
        this.markAdded(elmData);
    }.bind(this), 1000);
    this.getPatch().addNode(elmData.def.fullName);
}

NodeList.prototype.addSearch = function() {
    var nodeList  = this;

    var search = this.searchInput;

    // make seach field hide filtered results when user changes search request
    Kefir.fromEvents(search.node(), 'input')
         .merge(this.clearingEvents)
         .throttle(500)
         .map(function() { return search.node().value; })
         .onValue(function(searchString) {
             var visibleBefore = nodeList.currentlyVisible;
             nodeList.currentlyVisible = 0;
             nodeList.listElements.forEach(function(elmData) {
                 var index = elmData.def.fullName.indexOf(searchString);
                 if (index >= 0) { nodeList.setVisible(elmData); }
                 else { nodeList.setInvisible(elmData); };
                 elmData.visible = (index >= 0);
                 if (elmData.visible) nodeList.currentlyVisible++;
             });
             nodeList.recalculateSize(nodeList.listElements,
                            visibleBefore, nodeList.currentlyVisible);
         });
}

NodeList.prototype.addCtrlSpaceAndArrows = function() {
    var nodeList = this;

    var listElements = this.listElements;

    var search = this.searchInput,
        clearSearch = this.clearSearchButton;

    var clearingEvents = this.clearingEvents;

    // ctrl+space should focus on the search field and up/down arrows should
    // work for selection
    Kefir.merge([
            Kefir.fromEvents(document.body, 'keyup')
                 .filter(function(evt) {
                     // (control / alt / cmd) + space // TODO: double space (#63)?
                     return (evt.which == 32 || evt.keyCode == 32) && (evt.altKey || evt.metaKey || evt.ctrlKey);
                 }),
            Kefir.fromEvents(search.node(), 'click')
        ]).flatMap(function(switchedOn) {
             //console.log('start!');
             search.node().focus();
             if (listElements.length > 0) nodeList.select(listElements[0]);
             return Kefir.fromEvents(document.body, 'keyup')
                         .map(function(evt) { return evt.which || evt.keyCode; })
                         .filter(function(key) { return (key === 38) || (key === 40); })
                         .map(function(key) { return (key === 38) ? 'up' : 'down'; })
                         .takeUntilBy(Kefir.merge([
                                          Kefir.fromEvents(document.body, 'keyup')
                                               .filter(function(evt) {
                                                   return (evt.which == 13 || evt.keyCode == 13); // key == enter
                                               }).map(function() { return true; }),
                                          Kefir.fromEvents(document.body, 'keyup').filter(function(evt) {
                                              return (evt.which == 27 || evt.keyCode == 27); // key === escape
                                          }).map(function() { return false; }),
                                          Kefir.fromEvents(document.body, 'click').filter(function(evt) {
                                              return evt.target !== search.node();
                                          }).map(function() { return false; }),
                                          nodeList.clearingEvents.map(function() { return false; })/*,
                                          Kefir.fromEvents(search.node(), 'click')*/
                                      ]).take(1).onValue(function(doAdd) {
                                          if (doAdd && nodeList.selected) {
                                              nodeList.addNode(nodeList.selected);
                                          }
                                          search.node().blur();
                                          nodeList.selectNothing();
                                      }))
                         .onValue(function(key) {
                             if (nodeList.currentlyVisible == 0) return;
                             search.node().blur();
                             if (key === 'up') {
                                 var current = nodeList.selected ? nodeList.selected.prev : listElements[listElements.length - 1];
                                 while (current && !current.visible) {
                                     current = current.prev;
                                 }
                             } else if (key === 'down') {
                                 var current = nodeList.selected ? nodeList.selected.next : listElements[0];
                                 while (current && !current.visible) {
                                     current = current.next;
                                 }
                             }
                             if (current) nodeList.select(current);
                         });
         }).onValue(function() {});
}

return {
    'adaptToState': adaptToState,
    'numberToHex': numberToHex,
    'toHexColor': toHexColor,
    'getNodeTypesByToolkit': getNodeTypesByToolkit,
    'NodeList': NodeList
};

})();

;(function(global) {
  "use strict";

var Rpd = global.Rpd;
if (typeof Rpd === "undefined" && typeof require !== "undefined") {
    Rpd = require('rpd');
}

var numberToHex = RpdUtils.numberToHex;
var toHexColor = RpdUtils.toHexColor;

function howMuch(single, plural) {
    return function(list) {
        if (!list) return 'Nothing';
        if (list.length == 0) return 'No ' + plural;
        if (list.length == 1) return 'One ' + single;
        if (list.length == 2) return 'Two ' + plural;
        return list.length + ' ' + plural;
    };
}

Rpd.channeltype('util/boolean', {
    default: false,
    adapt: function(val) { return val ? 'true' : 'false' }
});

Rpd.channeltype('util/number', {
    default: 0,
    readonly: false,
    accept: function(val) {
        if (val === Infinity) return true;
        var parsed = parseFloat(val);
        return !isNaN(parsed) && isFinite(parsed);
    },
    adapt: function(val) { return parseFloat(val); }
});

Rpd.channeltype('util/wholenumber', {
    default: 0,
    allow: [ 'util/number' ],
    accept: function(val) {
        if (val === Infinity) return true;
        var parsed = parseFloat(val);
        return !isNaN(parsed) && isFinite(parsed);
    },
    adapt: function(val) { return Math.floor(parseFloat(val)); }
});

Rpd.channeltype('util/time', {
    default: 1000,
    accept: function(val) {
        var parsed = parseFloat(val);
        return !isNaN(parsed) && isFinite(parsed);
    },
    adapt: function(val) { return parseFloat(val); },
    show: function(val) { return (Math.floor(val / 10) / 100) + 's'; }
});

Rpd.channeltype('util/bang', {
    show: function(v) { return v ? '[Bang]' : '[None]'; },
    adapt: function(v) { return v ? {} : null; }
});

Rpd.channeltype('util/color', { show: toHexColor });

Rpd.channeltype('util/timestamped', {
    adapt: function(value) {
        return {
            value: value,
            timestamp: new Date().getTime()
        }
    }
});

Rpd.nodetype('util/number', {
    title: 'number',
    inlets:  { 'user-value': { type: 'util/number', default: 0, hidden: true } },
    outlets: { 'number':     { type: 'util/number' } },
    process: function(inlets) {
        return { 'number': inlets['user-value'] };
    }
});

Rpd.nodetype('util/random', function() {
    return {
        title: 'random',
        inlets:  { 'bang': { type: 'util/bang', default: {} },
                   'min': { type: 'util/number', default: 0 },
                   'max': { type: 'util/number', default: 100 } },
        outlets: { 'random': { type: 'util/number' } },
        process: function(inlets) {
            return { 'random': Math.floor(inlets.min + (Math.random() * (inlets.max - inlets.min))) };
        }
    }
});

Rpd.nodetype('util/bounded-number', {
    title: 'bounded number',
    inlets:  { 'min': { type: 'util/number', default: 0 },
               'max': { type: 'util/number', default: Infinity },
               'spinner': { type: 'util/number', default: 0, hidden: true } },
    outlets: { 'number':  { type: 'util/number' } },
    process: function(inlets) {
         if (!inlets.hasOwnProperty('spinner')) return;
         // comparison logic is in the renderer, since it communicates with
         // this node through a hidden spinner inlet
         return { 'number': inlets.spinner };
    }
});

Rpd.channeltype('util/boolean', { default: false,
                                  readonly: false,
                                  adapt: function(val) {
                                      return (val ? true : false);
                                  } });

Rpd.nodedescription('util/empty',
                    'Does not allow adding any inlets or outlets.');
Rpd.nodetype('util/empty', {
    title: 'empty',
    handle: {
        'inlet/add': function() {
            throw new Error('Empty node can not have any inlets');
        },
        'outlet/add': function() {
            throw new Error('Empty node can not have any outlets');
        }
    }
});

Rpd.nodetype('util/comment', {
    inlets: { 'text': { type: 'core/any', hidden: true },
              'width': { type: 'core/any', hidden: true } },
    process: function() {}
});

Rpd.nodetype('util/bang', {
    title: 'bang',
    inlets: { 'trigger': { type: 'util/bang', hidden: true } },
    outlets: { 'bang': { type: 'util/bang' } },
    process: function(inlets) {
        return inlets.trigger ? { 'bang': {} } : {};
    }
});

Rpd.nodetype('util/metro', function() {
    var lastStream;
    var firstTime = true;
    var pool = Kefir.pool();
    return {
        title: 'metro',
        inlets: { 'enabled': { type: 'util/boolean', default: true },
                  'period': { type: 'util/time', default: 3000 } },
        outlets: { 'bang': { type: 'util/bang' } },
        process: function(inlets) {
            if (lastStream) {
                firstTime = false;
                pool.unplug(lastStream);
            }
            if (!inlets.enabled && !firstTime) return;
            lastStream = Kefir.interval(inlets.period, {});
                            /*.filter(function() { return inlets.enabled; })*/
            pool.plug(lastStream);
            //return { 'out': firstTime ? pool : Kefir.never() };
            return firstTime ? { 'bang': pool } : {};
        }
    }
});

var DEFAULT_COLOR = { r: 0xED, g: 0x22, b: 0x5D };
Rpd.nodetype('util/color', {
    title: 'color',
    inlets: {
        'r': { type: 'util/wholenumber', default: DEFAULT_COLOR.r, label: 'red' },
        'g': { type: 'util/wholenumber', default: DEFAULT_COLOR.g, label: 'green' },
        'b': { type: 'util/wholenumber', default: DEFAULT_COLOR.b, label: 'blue' }
    },
    outlets: {
        'color': { type: 'util/color' }
    },
    process: function(inlets) { return { color: inlets }; }
});

Rpd.nodetype('util/sum-of-three', {
    title: 'sum of three',
    inlets: {
        'a': { type: 'util/number', label: 'A' },
        'b': { type: 'util/number', label: 'B' },
        'c': { type: 'util/number', label: 'C' }
    },
    outlets: {
        'sum': { type: 'util/number', label: '∑' }
    },
    process: function(inlets) {
        return { 'sum': (inlets.a || 0) + (inlets.b || 0) + (inlets.c || 0) };
    }
});

var adaptToState = RpdUtils.adaptToState;

Rpd.nodetype('util/knob', {
    title: 'knob',
    inlets: {
        'min': { type: 'util/number', default: 0 },
        'max': { type: 'util/number', default: 100 },
        'knob': { type: 'util/number', default: 0, hidden: true }
    },
    outlets: {
        'number': { type: 'util/number' }
    },
    process: function(inlets) { return { number: adaptToState(inlets, inlets.knob) }; }
});

Rpd.nodetype('util/dial', {
    title: 'dial',
    inlets: {
        'min': { type: 'util/number', default: 0 },
        'max': { type: 'util/number', default: 100 },
        'dial': { type: 'util/number', default: 0, hidden: true }
    },
    outlets: {
        'number': { type: 'util/wholenumber' }
    },
    process: function(inlets) { return { number: Math.floor(adaptToState(inlets, inlets.dial)) }; }
});

Rpd.channeltype('util/numbers', { show: howMuch('number', 'numbers') });

var DEFAULT_KNOB_COUNT = 4;

Rpd.nodetype('util/knobs', {
    title: 'knobs',
    inlets: {
        'min': { type: 'util/number', default: 0 },
        'max': { type: 'util/number', default: 100 },
        'count': { type: 'util/number', default: DEFAULT_KNOB_COUNT, hidden: true },
        'submit': { type: 'util/numbers', default: [], hidden: true }
    },
    outlets: {
        'numbers': { type: 'util/numbers' }
    },
    process: function(inlets) {
        return {
            numbers:
                inlets.submit ? inlets.submit.map(function(num) {
                                    return adaptToState(inlets, num);
                                })
                              : []
        };
    }
});

/*
Rpd.nodedescription('util/hot-and-cold', 'An example of cold inlet.');
Rpd.nodetype('util/hot-and-cold', {
    title: 'hot and cold',
    inlets: {
        'hot': { type: 'util/number', label: 'A', default: 1 },
        'cold': { type: 'util/number', label: 'B', default: 1, cold: true },
    },
    outlets: {
        'value': { type: 'util/any' }
    },
    process: function(inlets) {
        return { 'value': [ inlets.hot, inlets.cold ] };
    }
});
*/

Rpd.nodedescription('util/log', 'Log everything that goes in to console');
Rpd.nodetype('util/log', {
    title: 'log',
    inlets: {
        'what': { type: 'core/any' }
    },
    process: function(inlets) {
        // logging is done in the node renderer,
        // since it depends on the way of output (i.e. browser vs console)
    }
});

Rpd.nodetype('util/letter', {
    title: 'letter',
    inlets: {
        'code': { type: 'util/wholenumber' }
    },
    outlets: {
        'letter': { type: 'core/any' }
    },
    process: function(inlets) {
        return {
            'letter': String.fromCharCode(inlets.code + 97/*+ 65*/)
        }
    }
})

Rpd.nodetype('util/*', {
    title: '*',
    inlets: { 'a': { type: 'util/number' },
              'b': { type: 'util/number' } },
    outlets: { 'result': { type: 'util/number' } },
    process: function(inlets) { return { 'result': (inlets.a || 0) * (inlets.b || 0) }; }
});

Rpd.nodetype('util/+', {
    title: '+',
    inlets: { 'a': { type: 'util/number' },
              'b': { type: 'util/number' } },
    outlets: { 'result': { type: 'util/number' } },
    process: function(inlets) { return { 'result': (inlets.a || 0) + (inlets.b || 0) }; }
});

Rpd.nodetype('util/-', {
    title: '-',
    inlets: { 'a': { type: 'util/number' },
              'b': { type: 'util/number' } },
    outlets: { 'result': { type: 'util/number' } },
    process: function(inlets) { return { 'result': (inlets.a || 0) - (inlets.b || 0) }; }
});

Rpd.nodetype('util/÷', {
    title: '/',
    inlets: { 'a': { type: 'util/number' },
              'b': { type: 'util/number' } },
    outlets: { 'result': { type: 'util/number' } },
    process: function(inlets) { return { 'result': (inlets.a || 0) / (inlets.b || 0) }; }
});

Rpd.nodetype('util/mod', {
    title: '%',
    inlets: { 'a': { type: 'util/number' },
              'b': { type: 'util/number' } },
    outlets: { 'result': { type: 'util/number' } },
    process: function(inlets) { return { 'result': (inlets.a || 0) % (inlets.b || 0) }; }
});

Rpd.nodetype('util/mouse-pos', {
    title: 'mouse',
    inlets: {
        'x': { type: 'util/number', hidden: true, 'default': 0 },
        'y': { type: 'util/number', hidden: true, 'default': 0 }
    },
    outlets: {
        'x': { type: 'util/number' },
        'y': { type: 'util/number' }
    },
    process: function(inlets) { return inlets; }
});

Rpd.nodetype('util/mouse-pos-by-bang', {
    title: 'mouse + bang',
    inlets: {
        'bang': { type: 'util/bang' },
        'x': { type: 'util/number', hidden: true, 'default': 0, cold: true },
        'y': { type: 'util/number', hidden: true, 'default': 0, cold: true }
    },
    outlets: {
        'x': { type: 'util/number' },
        'y': { type: 'util/number' }
    },
    process: function(inlets) {
        //if (inlets.bang) {
            return { x: inlets.x, y: inlets.y };
        //};
    }
});

/* var howMuchColors = howMuch('color', 'colors');
Rpd.channeltype('util/palette', { show: function(val) { return howMuchColors(val.colors); } });
Rpd.channeltype('util/palettes', {});

var PALETTES = [
    [ '#f00', '#0f0', '#00f' ],
    [ '#ff0', '#0ff', '#f0f' ],
    [ '#000', '#666', '#aaa', '#fff' ]
];
Rpd.nodetype('util/palette', {
    inlets: {
        'selection': { type: 'util/palette', default: { index: 0, colors: PALETTES[0] }, label: 'selection', hidden: true },
        'palletes': { type: 'util/palettes', default: PALETTES, label: 'palettes', hidden: true }
    },
    outlets: {
        'palette': { type: 'util/palette' }
    },
    process: function(inlets) { return { palette: inlets.selection }; }
}); */

Rpd.nodedescription('util/nodelist', 'Add any node to active patch by type');
Rpd.nodetype('util/nodelist', { title: 'add nodes' });

Rpd.nodetypeicon('util/number',    '🔢'); // 'ℕ'
Rpd.nodetypeicon('util/log',       '🗒');
Rpd.nodetypeicon('util/nodelist',  '📃');
Rpd.nodetypeicon('util/knob',      '🎛');
Rpd.nodetypeicon('util/dial',      '🎛');
Rpd.nodetypeicon('util/knobs',     '🎛');
Rpd.nodetypeicon('util/color',     '🏮');
Rpd.nodetypeicon('util/bang',      '⊙');
Rpd.nodetypeicon('util/metro',     '⊚');
Rpd.nodetypeicon('util/empty',     '∅');
Rpd.nodetypeicon('util/mouse-pos', '🖱');
Rpd.nodetypeicon('util/mouse-pos-by-bang', '🖱');
//Rpd.nodetypeicon('util/random',   '≟');
//Rpd.nodetypeicon('util/bounded-number', '⩫');
//Rpd.nodetypeicon('util/sum-of-three', '∑');

})(this);

;(function(global) {
  "use strict";

var Rpd = global.Rpd;
if (typeof Rpd === "undefined" && typeof require !== "undefined") {
    Rpd = require('rpd');
}

function stopPropagation(event) {
    event.stopPropagation();
    return event;
}

var d3 = d3 || d3_tiny;

function svgNode(name) { return document.createElementNS(d3.ns.prefix.svg, name); }
function htmlNode(name) { return document.createElementNS(d3.ns.prefix.html, name); }

// FIXME: some nodes below are written with d3 / d3_tiny usage, some are not

/* ========================= util/number ========================= */

Rpd.channelrenderer('util/number', 'svg', {
    /* show: function(target, value) { }, */
    edit: function(target, inlet, valueIn) {
        var foElm = svgNode('foreignObject');
        foElm.setAttributeNS(null, 'width', 20);
        foElm.setAttributeNS(null, 'height', 30);
        var valInput = htmlNode('input');
        valInput.type = 'number';
        //valInput.style.position = 'absolute';
        valueIn.onValue(function(val) {
            valInput.value = val;
        });
        foElm.appendChild(valInput);
        target.appendChild(foElm);
        return Kefir.fromEvents(valInput, 'change')
                    .map(function() {
                        return valInput.value;
                    });
    }
});

/* ========================= util/wholenumber ========================= */

Rpd.channelrenderer('util/wholenumber', 'svg', Rpd.allChannelRenderers['util/number']['svg']);

/* ========================= util/random ========================= */

Rpd.noderenderer('util/random', 'svg', function() {
    return {
        size: { width: 40 }
    }
});

/* ========================= util/comment ========================= */

Rpd.noderenderer('util/comment', 'svg', function() {
    var textElm;
    return {
        size: { width: 100, height: 150 },
        first: function(bodyElm) {
            textElm = d3.select(bodyElm).append('text');
        },
        always: function(bodyElm, inlets, outlets) {
            if (inlets.width) textElm.attr('width', inlets.width);
            textElm.text(inlets.text || '<empty>');
        }
    }
});

/* ========================= util/log ========================= */

Rpd.noderenderer('util/log', 'svg', function() {
    var textElm;
    var capacity = 5;
    var savedValues = [];
    return {
        size: { width: 140, height: 30 },
        first: function(bodyElm) {
            textElm = d3.select(bodyElm).append('text');
        },
        always: function(bodyElm, inlets, outlets) {
            if (inlets.what) {
                if (savedValues.length > capacity) savedValues.shift();
                savedValues.push(inlets.what);
            }
            textElm.text((savedValues.length > 0) ? ('...' + savedValues.join(', ') + '.') : '...');
        }
    }
});

/* ========================= util/letter ========================= */

Rpd.noderenderer('util/letter', 'svg', function() {
    var textElm;
    return {
        first: function(bodyElm) {
            textElm = d3.select(bodyElm).append('text');
        },
        always: function(bodyElm, inlets, outlets) {
            textElm.text(outlets.letter);
        }
    }
});

/* ========================= util/bang ========================= */

Rpd.noderenderer('util/bang', 'svg', {
    size: { width: 30, height: 25 },
    first: function(bodyElm) {
        var circle = d3.select(svgNode('circle'))
                       .attr('r', 9).attr('fill', 'black')
                       .style('cursor', 'pointer')
                       .style('pointer-events', 'all');
        d3.select(bodyElm).append(circle.node());
        var circleClicks = Kefir.fromEvents(circle.node(), 'click');
        circleClicks.onValue(function() {
            circle.classed('rpd-util-bang-fresh', true);
        });
        circleClicks.delay(500).onValue(function() {
            circle.classed('rpd-util-bang-fresh', false);
        });
        return { 'trigger':
            { valueOut: circleClicks.map(function() { return {}; }) }
        };
    }
});

/* ========================= util/metro ========================= */

Rpd.noderenderer('util/metro', 'svg', function() {
    var circle;
    return {
        size: { width: 30, height: 25 },
        first: function(bodyElm) {
            circle = d3.select(svgNode('circle'))
                       .attr('r', 9).attr('fill', 'black')
                       .style('cursor', 'pointer')
                       .style('pointer-events', 'all');
            d3.select(bodyElm).append(circle.node());
        },
        always: function(bodyElm, inlets, outlets) {
            if (outlets.bang) {
                outlets.bang.onValue(function() {
                    circle.classed('rpd-util-metro-fresh', true);
                }).delay(500).onValue(function() {
                    circle.classed('rpd-util-metro-fresh', false);
                });
            }
        }
    }
});

/* ========================= util/palette ========================= */

/* Rpd.noderenderer('util/palette', 'svg', function() {
    var cellSide = 12;
    return {
        size: { width: 365, height: 60 },
        first: function(bodyElm) {
            var paletteChange = Kefir.emitter();
            var lastSelected, paletteGroups = [];
            d3.select(bodyElm)
              .append('g').attr('transform', 'translate(5, 0)')
              .call(function(target) {
                PALETTES.forEach(function(palette, i) {
                    target.append('g')
                          .attr('class', 'rpd-util-palette-variant')
                          .attr('transform', 'translate(' + (i * 14) + ', ' +
                                                            (-1 * (palette.length / 2 * cellSide)) + ')')
                          .call((function(palette) { return function(paletteGroup) {
                              palette.forEach(function(color, i) {
                                  paletteGroup.append('rect').attr('rx', 4)
                                              .attr('x', 0).attr('y', i * cellSide)
                                              .attr('width', cellSide).attr('height', cellSide)
                                              .attr('fill', color);
                              });
                              Kefir.fromEvents(paletteGroup.node(), 'click').onValue(function() {
                                  if (lastSelected) lastSelected.attr('class', 'rpd-util-palette-variant')
                                  paletteGroup.attr('class', 'rpd-util-palette-variant rpd-util-palette-active-variant');
                                  lastSelected = paletteGroup;
                                  paletteChange.emit(palette);
                              });
                              paletteGroups.push(paletteGroup);
                          } })(palette));
                });
            });
            lastSelected = paletteGroups[0];
            paletteGroups[0].attr('class', 'rpd-util-palette-variant rpd-util-palette-active-variant');
            return { 'selection': { valueOut: paletteChange } };
        }
    };
}); */

/* ========================= util/sum-of-three ========================= */

Rpd.noderenderer('util/sum-of-three', 'svg', function() {
    var textElement;
    return {
        //contentRule: 'replace',
        size: { width: 120, height: null },
        first: function(bodyElm) {
            textElement = svgNode('text');
            bodyElm.appendChild(textElement);
        },
        always: function(bodyElm, inlets, outlets) {
            textElement.innerHTML = '∑ (' + (inlets.a || '?') + ', '
                                          + (inlets.b || '?') + ', '
                                          + (inlets.c || '?') + ') = ' + (outlets.sum || '?');
        }
    }
});

/* ========================= util/knob & util/knobs ========================= */

var adaptToState = RpdUtils.adaptToState;

var defaultKnobConf = {
    speed: 1.5,
    radius: 13,
    width: 40, // radius * 2 + margin
    height: 40,
    //showIntTicks: false,
    //stickToInts: false,
    showGhost: true,
    adaptAngle: null,
    adaptValue: null
};

function createKnob(state, conf) {
    var lastValue = 0;
    //var state = { min: 0, max: 100 };

    var adaptAngle = conf.adaptAngle || function(s, v) { return v * 360; };

    return {
        init: function(parent, valueIn) {
            var hand, handGhost, face, text;
            var submit = Kefir.emitter();
            d3.select(parent)
              .call(function(bodyGroup) {
                  face = bodyGroup.append('circle').attr('r', conf.radius)
                                  .style('fill', 'rgba(200, 200, 200, .2)')
                                  .style('stroke-width', 2)
                                  .style('stroke', '#000');
                  handGhost = bodyGroup.append('line')
                                  .style('visibility', 'hidden')
                                  .attr('x1', 0).attr('y1', 0)
                                  .attr('x2', 0).attr('y2', conf.radius - 1)
                                  .style('stroke-width', 2)
                                  .style('stroke', 'rgba(255,255,255,0.1)');
                  hand = bodyGroup.append('line')
                                  .attr('x1', 0).attr('y1', 0)
                                  .attr('x2', 0).attr('y2', conf.radius)
                                  .style('stroke-width', 2)
                                  .style('stroke', '#000');
                  text = bodyGroup.append('text')
                                  .style('text-anchor', 'middle')
                                  .style('fill', '#fff')
                                  .text(0);
              });
            Kefir.fromEvents(parent, 'mousedown')
                 .map(stopPropagation)
                 .flatMap(function() {
                     if (conf.showGhost) handGhost.style('visibility', 'visible');
                     var values =
                        Kefir.fromEvents(document.body, 'mousemove')
                             //.throttle(16)
                             .takeUntilBy(Kefir.fromEvents(document.body, 'mouseup'))
                             .map(stopPropagation)
                             .map(function(event) {
                                 var faceRect = face.node().getBoundingClientRect();
                                 return { x: event.clientX - (faceRect.left + conf.radius),
                                          y: event.clientY - (faceRect.top + conf.radius) };
                             })
                             .map(function(coords) {
                                 var value = ((coords.y * conf.speed * -1) + 180) / 360;
                                 if (value < 0) {
                                     value = 0;
                                 } else if (value > 1) {
                                     value = 1;
                                 }
                                 return value;
                            });
                     values.last().onValue(function(val) {
                         lastValue = val;
                         handGhost.attr('transform', 'rotate(' + adaptAngle(state, lastValue) + ')')
                                  .style('visibility', 'hidden');
                         submit.emit(lastValue);
                     });
                     return values;
                 })
                 .merge(valueIn || Kefir.never())
                 .onValue(function(value) {
                     var valueText = adaptToState(state, value);
                     text.text(conf.adaptValue ? conf.adaptValue(valueText) : valueText);
                     hand.attr('transform', 'rotate(' + adaptAngle(state, value) + ')');
                 });
            return submit.merge(valueIn ? valueIn : Kefir.never());
        }
    }
}

function initKnobInGroup(knob, nodeRoot, id, count, width) {
    var submit;
    d3.select(nodeRoot).append('g')
      .attr('transform', 'translate(' + ((id * width) + (width / 2) - (count * width / 2)) + ',0)')
      .call(function(knobRoot) {
          knob.root = knobRoot;
          submit = knob.init(knobRoot.node());
      });
    return submit;
}

Rpd.noderenderer('util/knob', 'svg', function() {
    var state = { min: 0, max: 100 };
    var knob = createKnob(state, defaultKnobConf);

    return {
        size: { width: defaultKnobConf.width,
                height: defaultKnobConf.height },
        first: function(bodyElm, configurationIn) {
            var submit = knob.init(bodyElm,
                                   configurationIn.filter(function(c) { return c.hasOwnProperty('knob'); })
                                                  .map(function(c) { return c.knob; }));
            return {
                'knob': { valueOut: submit }
            };
        },
        always: function(bodyElm, inlets, outlets) {
            state.min = inlets.min || 0;
            state.max = inlets.max || 0;
        }
    };
});

Rpd.noderenderer('util/dial', 'svg', function() {
    // TODO: make it "sticky", so the hand would stick to int positions
    var state = { min: 0, max: 100 };
    var myKnobConf = {
        speed: defaultKnobConf.speed,
        radius: defaultKnobConf.radius,
        width: defaultKnobConf.width,
        height: defaultKnobConf.height,
        adaptValue: function(value) { return Math.floor(value); }
    };
    var knob = createKnob(state, myKnobConf);
    return {
        size: { width: myKnobConf.width,
                height: myKnobConf.height },
        first: function(bodyElm, configurationIn) {
            var submit = knob.init(bodyElm,
                                   configurationIn.filter(function(c) { return c.hasOwnProperty('dial'); })
                                                  .map(function(c) { return c.dial; }));
            return {
                'dial': { valueOut: submit }
            };
        },
        always: function(bodyElm, inlets, outlets) {
            state.min = inlets.min || 0;
            state.max = inlets.max || 0;
        }
    };
});

var DEFAULT_KNOB_COUNT = 4;

Rpd.noderenderer('util/knobs', 'svg', function() {
    var count = DEFAULT_KNOB_COUNT;
    var state = { min: 0, max: 100 };
    var knobs = [];
    for (var i = 0; i < count; i++) {
        knobs.push(createKnob(state, defaultKnobConf));
    }
    var nodeRoot;

    return {
        size: { width: count * defaultKnobConf.width, height: defaultKnobConf.height },
        //pivot: { x: 0, y: 0.5 },
        first: function(bodyElm) {
            var valueOut = Kefir.pool();
            nodeRoot = bodyElm;
            valueOut = Kefir.combine(
                knobs.map(function(knob, i) {
                    return initKnobInGroup(knob, nodeRoot, i, count, defaultKnobConf.width)
                           .merge(Kefir.constant(0));
                           // knob.init() returns stream of updates,
                           // so Kefir.combine will send every change
                })
            );
            return {
                'submit': { valueOut: valueOut }
            };
        },
        always: function(bodyElm, inlets, outlets) {
            state.min = inlets.min || 0;
            state.max = inlets.max || 0;
        }
    };
});

/* ========================= util/color ========================= */

var toHexColor = RpdUtils.toHexColor;

Rpd.noderenderer('util/color', 'svg', function() {
    var colorElm;
    return {
        size: { width: 50, height: 50 },
        first: function(bodyElm) {
            colorElm = svgNode('rect');
            colorElm.setAttributeNS(null, 'width', '30');
            colorElm.setAttributeNS(null, 'height', '30');
            colorElm.setAttributeNS(null, 'rx', '5');
            colorElm.setAttributeNS(null, 'ry', '5');
            colorElm.setAttributeNS(null, 'transform', 'translate(-15,-15)');
            colorElm.classList.add('rpd-util-color-display');
            bodyElm.appendChild(colorElm);
        },
        always: function(bodyElm, inlets, outlets) {
            colorElm.setAttributeNS(null, 'fill', toHexColor(outlets.color));
        }
    }
});

/* ========================= util/mouse-pos[-by-bang] ========================= */

// define separately to use for both `util/mouse-pos` and `util/mouse-pos-by-bang`
function mousePosNodeRenderer() {
    var radius = 20;
    var dirLine, dirCircle, posText, center;
    var xPosStream = Kefir.fromEvents(document.body, 'mousemove').throttle(16).map(function(evt) { return evt.x; });
    var yPosStream = Kefir.fromEvents(document.body, 'mousemove').throttle(16).map(function(evt) { return evt.y; });
    return {
        size: { width: radius * 2 + 10, height: radius * 2 + 10 },
        first: function(bodyElm) {
            var dirGroup = svgNode('g');
            dirCircle = svgNode('circle');
            dirLine = svgNode('line');
            posText = svgNode('text');

            dirLine.setAttributeNS(null, 'x1', 0);
            dirLine.setAttributeNS(null, 'y1', 0);
            dirLine.setAttributeNS(null, 'x2', 0);
            dirLine.setAttributeNS(null, 'y2', -radius);
            //dirLine.setAttributeNS(null, 'strokeWidth', 1);

            dirCircle.setAttributeNS(null, 'r', radius);

            dirGroup.appendChild(dirCircle);
            dirGroup.appendChild(dirLine);
            bodyElm.appendChild(dirGroup);
            bodyElm.appendChild(posText);

            return {
                x: { 'default': 0, valueOut: xPosStream },
                y: { 'default': 0, valueOut: yPosStream }
            }
        },
        always: function(bodyElm, inlets, outlets) {
            if (Number.isNaN(inlets.x) || Number.isNaN(inlets.y) || !inlets.y) return;
            var center = dirCircle.getBoundingClientRect();
            var angle = Math.atan2(inlets.y - (center.top + radius),
                                   inlets.x - (center.left + radius));
            dirLine.setAttributeNS(null, 'x2', Math.cos(angle) * radius);
            dirLine.setAttributeNS(null, 'y2', Math.sin(angle) * radius);
            posText.innerHTML = posText.innerText = '<' + inlets.x + ':' + inlets.y + '>';
        }
    }
}

Rpd.noderenderer('util/mouse-pos', 'svg', mousePosNodeRenderer);
Rpd.noderenderer('util/mouse-pos-by-bang', 'svg', mousePosNodeRenderer);

/* ========================= util/nodelist ========================= */

var NodeList = RpdUtils.NodeList;
var getNodeTypesByToolkit = RpdUtils.getNodeTypesByToolkit;

var nodeListSize = { width: 180, height: 300 };

var lineHeight = 22;  // find font-size?
var iconWidth = 11;
var inputWidth = nodeListSize.width - 40;
var inputHeight = 45;

Rpd.noderenderer('util/nodelist', 'svg', {
    size: nodeListSize,
    first: function(bodyElm) {

        var patch = this.patch;

        var nodeTypes = Rpd.allNodeTypes,
            nodeDescriptions = Rpd.allNodeDescriptions,
            toolkitIcons = Rpd.allToolkitIcons,
            nodeTypeIcons = Rpd.allNodeTypeIcons;

        var nodeTypesByToolkit = getNodeTypesByToolkit(nodeTypes);

        var bodyGroup = d3.select(bodyElm)
                           .append('g')
                           .attr('transform', 'translate(' + (-1 * nodeListSize.width / 2) + ','
                                                           + (-1 * nodeListSize.height / 2) + ')');
        var searchGroup = bodyGroup.append('g').classed('rpd-nodelist-search', true)
                                               .attr('transform', 'translate(12,12)');

        var nodeListSvg;

        var tookitElements = {},
            listElementsIdxByType = {};

        var nodeList = new NodeList({
            getPatch: function() { return patch; },
            buildList: function() {
                var listElements = [];

                var bodyRect = bodyGroup.node().getBoundingClientRect();

                var foreignDiv = bodyGroup.append(svgNode('foreignObject'))
                                       .append(htmlNode('div'))
                                       .style('width', (nodeListSize.width - 20) + 'px')
                                       .style('height', (nodeListSize.height - inputHeight) + 'px')
                                       .style('overflow-y', 'scroll')
                                       .style('position', 'fixed').style('left', 10 + 'px')
                                                                  .style('top', inputHeight + 'px');

                nodeListSvg = foreignDiv.append(svgNode('svg'))
                                        .classed('rpd-nodelist-list', true)
                                        .attr('width', (nodeListSize.width - 12) + 'px');
                var lastY = 0;

                nodeListSvg.append('g')
                  .call(function(g) {
                      Object.keys(nodeTypesByToolkit).forEach(function(toolkit) {

                          var toolkitGroup = g.append('g').classed('rpd-nodelist-toolkit', true)
                                              .attr('transform', 'translate(0,' + lastY + ')')
                           .call(function(g) {
                                if (toolkitIcons[toolkit]) g.append('text').attr('class', 'rpd-nodelist-toolkit-icon').text(toolkitIcons[toolkit]);
                                g.append('text').attr('class', 'rpd-nodelist-toolkit-name').text(toolkit)
                           });

                          tookitElements[toolkit] = toolkitGroup;

                          lastY += lineHeight;

                          g.append('g').classed('rpd-nodelist-nodetypes', true)
                           .call(function(g) {
                                nodeTypesByToolkit[toolkit].types.forEach(function(nodeTypeDef) {
                                    var nodeType = nodeTypeDef.fullName;
                                    g.append('g').classed('rpd-nodelist-nodetype', true)
                                      .attr('transform', 'translate(0,' + lastY + ')')
                                     .call(function(g) {

                                          var hasDescription = nodeDescriptions[nodeType] ? true : false;

                                          var elmData = { def: nodeTypeDef,
                                                          element: g,
                                                          hasDescription: hasDescription,
                                                          initialY: lastY };

                                          g.data(elmData);

                                          g.append('rect').attr('class', 'rpd-nodelist-item-bg')
                                                          .attr('x', 0).attr('y', -5).attr('rx', 5).attr('ry', 5)
                                                          .attr('width', nodeListSize.width - 20)
                                                          .attr('height', (hasDescription ? (lineHeight * 1.5) : lineHeight) - 5);
                                          g.append('text').attr('class', 'rpd-nodelist-icon').text(nodeTypeIcons[nodeType] || ' ')
                                                          .attr('x', (iconWidth / 2)).attr('y', 5);
                                          g.append('text').attr('class', 'rpd-nodelist-fulltypename')
                                                          .attr('transform', 'translate(' + (iconWidth + 4) + ',0)')
                                                          .text(nodeTypeDef.toolkit + '/' + nodeTypeDef.name)
                                          if (hasDescription) {
                                              lastY += (lineHeight * 0.5);
                                              g.select('rect').attr('title', nodeDescriptions[nodeType]);
                                              g.append('text').attr('class', 'rpd-nodelist-description')
                                                              .attr('transform', 'translate(3,' + (lineHeight * 0.6) + ')')
                                                              .text(nodeDescriptions[nodeType]);
                                          }

                                          listElements.push(elmData);

                                          listElementsIdxByType[nodeType] = listElements.length - 1;

                                          lastY += lineHeight;

                                      });
                                });
                           });

                      });
                  });

                nodeListSvg.attr('height', lastY + 'px');

                return listElements;
            },
            recalculateSize: function(listElements) {
                var lastY = 0;

                Object.keys(nodeTypesByToolkit).forEach(function(toolkit) {
                    tookitElements[toolkit].attr('transform', 'translate(0,' + lastY + ')');

                    lastY += lineHeight;

                    var elmDataIdx, elmData;

                    nodeTypesByToolkit[toolkit].types.forEach(function(nodeTypeDef) {
                        elmDataIdx = listElementsIdxByType[nodeTypeDef.fullName];
                        elmData = listElements[elmDataIdx];

                        if (elmData.visible) {
                            elmData.element.attr('transform', 'translate(0,' + lastY + ')');
                            lastY += lineHeight;
                            if (elmData.hasDescription) lastY += (lineHeight * 0.5);
                        }

                    });

                });

                nodeListSvg.attr('height', lastY + 'px');
            },
            createSearchInput: function() {
                var foElm = svgNode('foreignObject');
                foElm.setAttributeNS(null, 'width', inputWidth);
                foElm.setAttributeNS(null, 'height', 20);
                var input = htmlNode('input');
                input.setAttribute('type', 'text');
                input.style.width = inputWidth + 'px';
                foElm.appendChild(input);
                searchGroup.append(foElm);
                return d3.select(input);
            },
            createClearSearchButton: function() {
                searchGroup.append('rect').attr('transform', 'translate(' + (nodeListSize.width - 32) + ',7)')
                           .attr('width', 12).attr('height', 12).attr('rx', 5);
                return searchGroup.append('text').text('x')
                                  .attr('transform', 'translate(' + (nodeListSize.width - 26) + ',12)');
            },
            clearSearchInput: function(searchInput) { searchInput.node().value = ''; },
            markSelected: function(elmData) { elmData.element.classed('rpd-nodelist-selected', true); },
            markDeselected: function(elmData) { elmData.element.classed('rpd-nodelist-selected', false); },
            markAdding: function(elmData) { elmData.element.classed('rpd-nodelist-add-effect', true); },
            markAdded: function(elmData) { elmData.element.classed('rpd-nodelist-add-effect', false); },
            setVisible: function(elmData) { elmData.element.style('display', 'list-item'); },
            setInvisible: function(elmData) { elmData.element.style('display', 'none'); }
        });

        nodeList.addOnClick();
        nodeList.addSearch();
        nodeList.addCtrlSpaceAndArrows();

    }
});

})(this);
